{"version":3,"file":"static/chunks/733-7c4f559d5304400cfad4.js","mappings":"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","sources":["webpack://_N_E/./src/components/MessageDialog.tsx","webpack://_N_E/./src/components/RecoveryKeyModal.tsx","webpack://_N_E/./src/services/billingService.ts","webpack://_N_E/./src/services/downloadManager.ts","webpack://_N_E/./src/services/fileService.ts","webpack://_N_E/./src/services/motionPhotoService.ts","webpack://_N_E/./src/services/upload/exifService.ts","webpack://_N_E/./src/services/upload/metadataService.ts","webpack://_N_E/./src/services/upload/readFileService.ts","webpack://_N_E/./public/images/black-thumbnail-b64.ts","webpack://_N_E/./src/services/upload/queueProcessor.ts","webpack://_N_E/./src/services/ffmpegService.ts","webpack://_N_E/./src/services/upload/thumbnailService.ts","webpack://_N_E/./src/services/upload/uiService.ts","webpack://_N_E/./src/services/upload/uploadHttpClient.ts","webpack://_N_E/./src/services/upload/encryptionService.ts","webpack://_N_E/./src/services/upload/multiPartUploadService.ts","webpack://_N_E/./src/services/upload/uploadService.ts","webpack://_N_E/./src/utils/billingUtil.ts","webpack://_N_E/./src/utils/file/index.ts","webpack://_N_E/./src/utils/network/index.ts","webpack://_N_E/./src/utils/storage/index.ts"],"sourcesContent":["import React from 'react';\nimport { Button, Modal } from 'react-bootstrap';\nimport constants from 'utils/strings/constants';\n\nexport interface MessageAttributes {\n    title?: string;\n    staticBackdrop?: boolean;\n    nonClosable?: boolean;\n    content?: any;\n    close?: { text?: string; variant?: string; action?: () => void };\n    proceed?: {\n        text: string;\n        action: () => void;\n        variant: string;\n        disabled?: boolean;\n    };\n}\n\nexport type SetDialogMessage = React.Dispatch<\n    React.SetStateAction<MessageAttributes>\n>;\ntype Props = React.PropsWithChildren<{\n    show: boolean;\n    onHide: () => void;\n    attributes: MessageAttributes;\n    size?: 'sm' | 'lg' | 'xl';\n}>;\nexport default function MessageDialog({\n    attributes,\n    children,\n    ...props\n}: Props) {\n    if (!attributes) {\n        return <Modal />;\n    }\n    return (\n        <Modal\n            {...props}\n            onHide={attributes.nonClosable ? () => null : props.onHide}\n            centered\n            backdrop={attributes.staticBackdrop ? 'static' : true}>\n            <Modal.Header\n                style={{ borderBottom: 'none' }}\n                closeButton={!attributes.nonClosable}>\n                {attributes.title && (\n                    <Modal.Title>{attributes.title}</Modal.Title>\n                )}\n            </Modal.Header>\n            {(children || attributes?.content) && (\n                <Modal.Body style={{ borderTop: '1px solid #444' }}>\n                    {children || (\n                        <p style={{ fontSize: '1.25rem', marginBottom: 0 }}>\n                            {attributes.content}\n                        </p>\n                    )}\n                </Modal.Body>\n            )}\n            {(attributes.close || attributes.proceed) && (\n                <Modal.Footer style={{ borderTop: 'none' }}>\n                    <div\n                        style={{\n                            display: 'flex',\n                            flexWrap: 'wrap',\n                        }}>\n                        {attributes.close && (\n                            <Button\n                                variant={`outline-${\n                                    attributes.close?.variant ?? 'secondary'\n                                }`}\n                                onClick={() => {\n                                    attributes.close.action &&\n                                        attributes.close?.action();\n                                    props.onHide();\n                                }}\n                                style={{\n                                    padding: '6px 3em',\n                                    margin: '0 20px',\n                                    marginBottom: '20px',\n                                    flex: 1,\n                                    whiteSpace: 'nowrap',\n                                }}>\n                                {attributes.close?.text ?? constants.OK}\n                            </Button>\n                        )}\n                        {attributes.proceed && (\n                            <Button\n                                variant={`outline-${\n                                    attributes.proceed?.variant ?? 'primary'\n                                }`}\n                                onClick={() => {\n                                    attributes.proceed.action();\n                                    props.onHide();\n                                }}\n                                style={{\n                                    padding: '6px 3em',\n                                    margin: '0 20px',\n                                    marginBottom: '20px',\n                                    flex: 1,\n                                    whiteSpace: 'nowrap',\n                                }}\n                                disabled={attributes.proceed.disabled}>\n                                {attributes.proceed.text}\n                            </Button>\n                        )}\n                    </div>\n                </Modal.Footer>\n            )}\n        </Modal>\n    );\n}\n","import React, { useEffect, useState } from 'react';\nimport { downloadAsFile } from 'utils/file';\nimport { getRecoveryKey } from 'utils/crypto';\nimport constants from 'utils/strings/constants';\nimport MessageDialog from './MessageDialog';\nimport EnteSpinner from './EnteSpinner';\nimport styled from 'styled-components';\nconst bip39 = require('bip39');\n// mobile client library only supports english.\nbip39.setDefaultWordlist('english');\nexport const CodeBlock = styled.div<{ height: number }>`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #1a1919;\n    height: ${(props) => props.height}px;\n    padding-left: 30px;\n    padding-right: 20px;\n    color: white;\n    margin: 20px 0;\n    width: 100%;\n`;\n\nexport const FreeFlowText = styled.div`\n    word-wrap: break-word;\n    overflow-wrap: break-word;\n    min-width: 30%;\n    text-align: left;\n`;\ninterface Props {\n    show: boolean;\n    onHide: () => void;\n    somethingWentWrong: any;\n}\nfunction RecoveryKeyModal({ somethingWentWrong, ...props }: Props) {\n    const [recoveryKey, setRecoveryKey] = useState(null);\n    useEffect(() => {\n        if (!props.show) {\n            return;\n        }\n        const main = async () => {\n            const recoveryKey = await getRecoveryKey();\n            if (!recoveryKey) {\n                somethingWentWrong();\n                props.onHide();\n            }\n            setRecoveryKey(bip39.entropyToMnemonic(recoveryKey));\n        };\n        main();\n    }, [props.show]);\n\n    function onSaveClick() {\n        downloadAsFile(constants.RECOVERY_KEY_FILENAME, recoveryKey);\n        onClose();\n    }\n    function onClose() {\n        props.onHide();\n    }\n    return (\n        <MessageDialog\n            show={props.show}\n            onHide={onClose}\n            size=\"lg\"\n            attributes={{\n                title: constants.DOWNLOAD_RECOVERY_KEY,\n                close: {\n                    text: constants.SAVE_LATER,\n                    variant: 'danger',\n                },\n                staticBackdrop: true,\n                proceed: {\n                    text: constants.SAVE,\n                    action: onSaveClick,\n                    disabled: !recoveryKey,\n                    variant: 'success',\n                },\n            }}>\n            <p>{constants.RECOVERY_KEY_DESCRIPTION}</p>\n            <CodeBlock height={150}>\n                {recoveryKey ? (\n                    <FreeFlowText>{recoveryKey}</FreeFlowText>\n                ) : (\n                    <EnteSpinner />\n                )}\n            </CodeBlock>\n            <p>{constants.KEY_NOT_STORED_DISCLAIMER}</p>\n        </MessageDialog>\n    );\n}\nexport default RecoveryKeyModal;\n","import { getEndpoint, getPaymentsUrl } from 'utils/common/apiUtil';\nimport { getToken } from 'utils/common/key';\nimport { setData, LS_KEYS } from 'utils/storage/localStorage';\nimport { convertToHumanReadable } from 'utils/billingUtil';\nimport HTTPService from './HTTPService';\nimport { logError } from 'utils/sentry';\nimport { getPaymentToken } from './userService';\n\nconst ENDPOINT = getEndpoint();\n\nenum PaymentActionType {\n    Buy = 'buy',\n    Update = 'update',\n}\nexport interface Subscription {\n    id: number;\n    userID: number;\n    productID: string;\n    storage: number;\n    originalTransactionID: string;\n    expiryTime: number;\n    paymentProvider: string;\n    attributes: {\n        isCancelled: boolean;\n    };\n    price: string;\n    period: string;\n}\nexport interface Plan {\n    id: string;\n    androidID: string;\n    iosID: string;\n    storage: number;\n    price: string;\n    period: string;\n    stripeID: string;\n}\n\nexport const FREE_PLAN = 'free';\nclass billingService {\n    public async getPlans(): Promise<Plan[]> {\n        try {\n            const response = await HTTPService.get(\n                `${ENDPOINT}/billing/plans/v2`\n            );\n            const { plans } = response.data;\n            return plans;\n        } catch (e) {\n            logError(e, 'failed to get plans');\n        }\n    }\n\n    public async syncSubscription() {\n        try {\n            const response = await HTTPService.get(\n                `${ENDPOINT}/billing/subscription`,\n                null,\n                {\n                    'X-Auth-Token': getToken(),\n                }\n            );\n            const { subscription } = response.data;\n            setData(LS_KEYS.SUBSCRIPTION, subscription);\n        } catch (e) {\n            logError(e, \"failed to get user's subscription details\");\n        }\n    }\n\n    public async buySubscription(productID: string) {\n        try {\n            const paymentToken = await getPaymentToken();\n            await this.redirectToPayments(\n                paymentToken,\n                productID,\n                PaymentActionType.Buy\n            );\n        } catch (e) {\n            logError(e, 'unable to buy subscription');\n            throw e;\n        }\n    }\n\n    public async updateSubscription(productID: string) {\n        try {\n            const paymentToken = await getPaymentToken();\n            await this.redirectToPayments(\n                paymentToken,\n                productID,\n                PaymentActionType.Update\n            );\n        } catch (e) {\n            logError(e, 'subscription update failed');\n            throw e;\n        }\n    }\n\n    public async cancelSubscription() {\n        try {\n            const response = await HTTPService.post(\n                `${ENDPOINT}/billing/stripe/cancel-subscription`,\n                null,\n                null,\n                {\n                    'X-Auth-Token': getToken(),\n                }\n            );\n            const { subscription } = response.data;\n            setData(LS_KEYS.SUBSCRIPTION, subscription);\n        } catch (e) {\n            logError(e, 'subscription cancel failed');\n            throw e;\n        }\n    }\n\n    public async activateSubscription() {\n        try {\n            const response = await HTTPService.post(\n                `${ENDPOINT}/billing/stripe/activate-subscription`,\n                null,\n                null,\n                {\n                    'X-Auth-Token': getToken(),\n                }\n            );\n            const { subscription } = response.data;\n            setData(LS_KEYS.SUBSCRIPTION, subscription);\n        } catch (e) {\n            logError(e, 'failed to activate subscription');\n            throw e;\n        }\n    }\n\n    public async verifySubscription(\n        sessionID: string = null\n    ): Promise<Subscription> {\n        try {\n            const token = getToken();\n            if (!token) {\n                return;\n            }\n            const response = await HTTPService.post(\n                `${ENDPOINT}/billing/verify-subscription`,\n                {\n                    paymentProvider: 'stripe',\n                    productID: null,\n                    VerificationData: sessionID,\n                },\n                null,\n                {\n                    'X-Auth-Token': token,\n                }\n            );\n            const { subscription } = response.data;\n            setData(LS_KEYS.SUBSCRIPTION, subscription);\n            return subscription;\n        } catch (err) {\n            logError(err, 'Error while verifying subscription');\n            throw err;\n        }\n    }\n\n    public async redirectToPayments(\n        paymentToken: string,\n        productID: string,\n        action: string\n    ) {\n        try {\n            window.location.href = `${getPaymentsUrl()}?productID=${productID}&paymentToken=${paymentToken}&action=${action}&redirectURL=${\n                window.location.origin\n            }/gallery`;\n        } catch (e) {\n            logError(e, 'unable to get payments url');\n            throw e;\n        }\n    }\n\n    public async redirectToCustomerPortal() {\n        try {\n            const response = await HTTPService.get(\n                `${ENDPOINT}/billing/stripe/customer-portal`,\n                { redirectURL: `${window.location.origin}/gallery` },\n                {\n                    'X-Auth-Token': getToken(),\n                }\n            );\n            window.location.href = response.data.url;\n        } catch (e) {\n            logError(e, 'unable to get customer portal url');\n            throw e;\n        }\n    }\n\n    public async getUsage() {\n        try {\n            const response = await HTTPService.get(\n                `${ENDPOINT}/billing/usage`,\n                { startTime: 0, endTime: Date.now() * 1000 },\n                {\n                    'X-Auth-Token': getToken(),\n                }\n            );\n            return convertToHumanReadable(response.data.usage);\n        } catch (e) {\n            logError(e, 'error getting usage');\n        }\n    }\n}\n\nexport default new billingService();\n","import { getToken } from 'utils/common/key';\nimport { getFileUrl, getThumbnailUrl } from 'utils/common/apiUtil';\nimport CryptoWorker from 'utils/crypto';\nimport {\n    generateStreamFromArrayBuffer,\n    convertForPreview,\n    needsConversionForPreview,\n} from 'utils/file';\nimport HTTPService from './HTTPService';\nimport { File, FILE_TYPE } from './fileService';\nimport { logError } from 'utils/sentry';\n\nclass DownloadManager {\n    private fileObjectUrlPromise = new Map<string, Promise<string>>();\n    private thumbnailObjectUrlPromise = new Map<number, Promise<string>>();\n\n    public async getThumbnail(file: File) {\n        try {\n            const token = getToken();\n            if (!token) {\n                return null;\n            }\n            if (!this.thumbnailObjectUrlPromise.get(file.id)) {\n                const downloadPromise = async () => {\n                    const thumbnailCache = await caches.open('thumbs');\n                    const cacheResp: Response = await thumbnailCache.match(\n                        file.id.toString()\n                    );\n                    if (cacheResp) {\n                        return URL.createObjectURL(await cacheResp.blob());\n                    }\n                    const thumb = await this.downloadThumb(token, file);\n                    const thumbBlob = new Blob([thumb]);\n                    try {\n                        await thumbnailCache.put(\n                            file.id.toString(),\n                            new Response(thumbBlob)\n                        );\n                    } catch (e) {\n                        // TODO: handle storage full exception.\n                    }\n                    return URL.createObjectURL(thumbBlob);\n                };\n                this.thumbnailObjectUrlPromise.set(file.id, downloadPromise());\n            }\n\n            return await this.thumbnailObjectUrlPromise.get(file.id);\n        } catch (e) {\n            this.thumbnailObjectUrlPromise.delete(file.id);\n            logError(e, 'get preview Failed');\n            throw e;\n        }\n    }\n\n    downloadThumb = async (token: string, file: File) => {\n        const resp = await HTTPService.get(\n            getThumbnailUrl(file.id),\n            null,\n            { 'X-Auth-Token': token },\n            { responseType: 'arraybuffer' }\n        );\n        const worker = await new CryptoWorker();\n        const decrypted: Uint8Array = await worker.decryptThumbnail(\n            new Uint8Array(resp.data),\n            await worker.fromB64(file.thumbnail.decryptionHeader),\n            file.key\n        );\n        return decrypted;\n    };\n\n    getFile = async (file: File, forPreview = false) => {\n        const shouldBeConverted = forPreview && needsConversionForPreview(file);\n        const fileKey = shouldBeConverted\n            ? `${file.id}_converted`\n            : `${file.id}`;\n        try {\n            const getFilePromise = async (convert: boolean) => {\n                const fileStream = await this.downloadFile(file);\n                let fileBlob = await new Response(fileStream).blob();\n                if (convert) {\n                    fileBlob = await convertForPreview(file, fileBlob);\n                }\n                return URL.createObjectURL(fileBlob);\n            };\n            if (!this.fileObjectUrlPromise.get(fileKey)) {\n                this.fileObjectUrlPromise.set(\n                    fileKey,\n                    getFilePromise(shouldBeConverted)\n                );\n            }\n            const fileURL = await this.fileObjectUrlPromise.get(fileKey);\n            return fileURL;\n        } catch (e) {\n            this.fileObjectUrlPromise.delete(fileKey);\n            logError(e, 'Failed to get File');\n            throw e;\n        }\n    };\n\n    public async getCachedOriginalFile(file: File) {\n        return await this.fileObjectUrlPromise.get(file.id.toString());\n    }\n\n    async downloadFile(file: File) {\n        const worker = await new CryptoWorker();\n        const token = getToken();\n        if (!token) {\n            return null;\n        }\n        if (\n            file.metadata.fileType === FILE_TYPE.IMAGE ||\n            file.metadata.fileType === FILE_TYPE.LIVE_PHOTO\n        ) {\n            const resp = await HTTPService.get(\n                getFileUrl(file.id),\n                null,\n                { 'X-Auth-Token': token },\n                { responseType: 'arraybuffer' }\n            );\n            const decrypted: any = await worker.decryptFile(\n                new Uint8Array(resp.data),\n                await worker.fromB64(file.file.decryptionHeader),\n                file.key\n            );\n            return generateStreamFromArrayBuffer(decrypted);\n        }\n        const resp = await fetch(getFileUrl(file.id), {\n            headers: {\n                'X-Auth-Token': token,\n            },\n        });\n        const reader = resp.body.getReader();\n        const stream = new ReadableStream({\n            async start(controller) {\n                const decryptionHeader = await worker.fromB64(\n                    file.file.decryptionHeader\n                );\n                const fileKey = await worker.fromB64(file.key);\n                const { pullState, decryptionChunkSize } =\n                    await worker.initDecryption(decryptionHeader, fileKey);\n                let data = new Uint8Array();\n                // The following function handles each data chunk\n                function push() {\n                    // \"done\" is a Boolean and value a \"Uint8Array\"\n                    reader.read().then(async ({ done, value }) => {\n                        // Is there more data to read?\n                        if (!done) {\n                            const buffer = new Uint8Array(\n                                data.byteLength + value.byteLength\n                            );\n                            buffer.set(new Uint8Array(data), 0);\n                            buffer.set(new Uint8Array(value), data.byteLength);\n                            if (buffer.length > decryptionChunkSize) {\n                                const fileData = buffer.slice(\n                                    0,\n                                    decryptionChunkSize\n                                );\n                                const { decryptedData } =\n                                    await worker.decryptChunk(\n                                        fileData,\n                                        pullState\n                                    );\n                                controller.enqueue(decryptedData);\n                                data = buffer.slice(decryptionChunkSize);\n                            } else {\n                                data = buffer;\n                            }\n                            push();\n                        } else {\n                            if (data) {\n                                const { decryptedData } =\n                                    await worker.decryptChunk(data, pullState);\n                                controller.enqueue(decryptedData);\n                                data = null;\n                            }\n                            controller.close();\n                        }\n                    });\n                }\n\n                push();\n            },\n        });\n        return stream;\n    }\n}\n\nexport default new DownloadManager();\n","import { getEndpoint } from 'utils/common/apiUtil';\nimport localForage from 'utils/storage/localForage';\n\nimport { getToken } from 'utils/common/key';\nimport {\n    DataStream,\n    EncryptionResult,\n    MetadataObject,\n} from './upload/uploadService';\nimport { Collection } from './collectionService';\nimport HTTPService from './HTTPService';\nimport { logError } from 'utils/sentry';\nimport { decryptFile, mergeMetadata, sortFiles } from 'utils/file';\nimport CryptoWorker from 'utils/crypto';\n\nconst ENDPOINT = getEndpoint();\n\nconst FILES_TABLE = 'files';\n\nexport const MIN_EDITED_CREATION_TIME = new Date(1800, 0, 1);\nexport const MAX_EDITED_CREATION_TIME = new Date();\nexport const ALL_TIME = new Date(1800, 0, 1, 23, 59, 59);\n\nexport const MAX_EDITED_FILE_NAME_LENGTH = 100;\n\nexport interface fileAttribute {\n    encryptedData?: DataStream | Uint8Array;\n    objectKey?: string;\n    decryptionHeader: string;\n}\n\nexport enum FILE_TYPE {\n    IMAGE,\n    VIDEO,\n    LIVE_PHOTO,\n    OTHERS,\n}\n\n/*  Build error occurred\n    ReferenceError: Cannot access 'FILE_TYPE' before initialization\n    when it was placed in readFileService\n*/\n// list of format that were missed by type-detection for some files.\nexport const FORMAT_MISSED_BY_FILE_TYPE_LIB = [\n    { fileType: FILE_TYPE.IMAGE, exactType: 'jpeg' },\n    { fileType: FILE_TYPE.IMAGE, exactType: 'jpg' },\n    { fileType: FILE_TYPE.VIDEO, exactType: 'webm' },\n];\n\nexport enum VISIBILITY_STATE {\n    VISIBLE,\n    ARCHIVED,\n}\n\nexport interface MagicMetadataCore {\n    version: number;\n    count: number;\n    header: string;\n    data: Record<string, any>;\n}\n\nexport interface EncryptedMagicMetadataCore\n    extends Omit<MagicMetadataCore, 'data'> {\n    data: string;\n}\n\nexport interface MagicMetadataProps {\n    visibility?: VISIBILITY_STATE;\n}\n\nexport interface MagicMetadata extends Omit<MagicMetadataCore, 'data'> {\n    data: MagicMetadataProps;\n}\n\nexport interface PublicMagicMetadataProps {\n    editedTime?: number;\n    editedName?: string;\n}\n\nexport interface PublicMagicMetadata extends Omit<MagicMetadataCore, 'data'> {\n    data: PublicMagicMetadataProps;\n}\n\nexport interface File {\n    id: number;\n    collectionID: number;\n    ownerID: number;\n    file: fileAttribute;\n    thumbnail: fileAttribute;\n    metadata: MetadataObject;\n    magicMetadata: MagicMetadata;\n    pubMagicMetadata: PublicMagicMetadata;\n    encryptedKey: string;\n    keyDecryptionNonce: string;\n    key: string;\n    src: string;\n    msrc: string;\n    html: string;\n    w: number;\n    h: number;\n    isDeleted: boolean;\n    isTrashed?: boolean;\n    deleteBy?: number;\n    dataIndex: number;\n    updationTime: number;\n}\n\ninterface UpdateMagicMetadataRequest {\n    metadataList: UpdateMagicMetadata[];\n}\n\ninterface UpdateMagicMetadata {\n    id: number;\n    magicMetadata: EncryptedMagicMetadataCore;\n}\n\nexport const NEW_MAGIC_METADATA: MagicMetadataCore = {\n    version: 0,\n    data: {},\n    header: null,\n    count: 0,\n};\n\ninterface TrashRequest {\n    items: TrashRequestItems[];\n}\n\ninterface TrashRequestItems {\n    fileID: number;\n    collectionID: number;\n}\nexport const getLocalFiles = async () => {\n    const files: Array<File> =\n        (await localForage.getItem<File[]>(FILES_TABLE)) || [];\n    return files;\n};\n\nexport const setLocalFiles = async (files: File[]) => {\n    await localForage.setItem(FILES_TABLE, files);\n};\n\nconst getCollectionLastSyncTime = async (collection: Collection) =>\n    (await localForage.getItem<number>(`${collection.id}-time`)) ?? 0;\n\nexport const syncFiles = async (\n    collections: Collection[],\n    setFiles: (files: File[]) => void\n) => {\n    const localFiles = await getLocalFiles();\n    let files = await removeDeletedCollectionFiles(collections, localFiles);\n    if (files.length !== localFiles.length) {\n        await setLocalFiles(files);\n        setFiles([...sortFiles(mergeMetadata(files))]);\n    }\n    for (const collection of collections) {\n        if (!getToken()) {\n            continue;\n        }\n        const lastSyncTime = await getCollectionLastSyncTime(collection);\n        if (collection.updationTime === lastSyncTime) {\n            continue;\n        }\n        const fetchedFiles =\n            (await getFiles(collection, lastSyncTime, files, setFiles)) ?? [];\n        files.push(...fetchedFiles);\n        const latestVersionFiles = new Map<string, File>();\n        files.forEach((file) => {\n            const uid = `${file.collectionID}-${file.id}`;\n            if (\n                !latestVersionFiles.has(uid) ||\n                latestVersionFiles.get(uid).updationTime < file.updationTime\n            ) {\n                latestVersionFiles.set(uid, file);\n            }\n        });\n        files = [];\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const [_, file] of latestVersionFiles) {\n            if (file.isDeleted) {\n                continue;\n            }\n            files.push(file);\n        }\n        await setLocalFiles(files);\n        await localForage.setItem(\n            `${collection.id}-time`,\n            collection.updationTime\n        );\n        setFiles([...sortFiles(mergeMetadata(files))]);\n    }\n    return sortFiles(mergeMetadata(files));\n};\n\nexport const getFiles = async (\n    collection: Collection,\n    sinceTime: number,\n    files: File[],\n    setFiles: (files: File[]) => void\n): Promise<File[]> => {\n    try {\n        const decryptedFiles: File[] = [];\n        let time = sinceTime;\n        let resp;\n        do {\n            const token = getToken();\n            if (!token) {\n                break;\n            }\n            resp = await HTTPService.get(\n                `${ENDPOINT}/collections/v2/diff`,\n                {\n                    collectionID: collection.id,\n                    sinceTime: time,\n                },\n                {\n                    'X-Auth-Token': token,\n                }\n            );\n\n            decryptedFiles.push(\n                ...(await Promise.all(\n                    resp.data.diff.map(async (file: File) => {\n                        if (!file.isDeleted) {\n                            file = await decryptFile(file, collection);\n                        }\n                        return file;\n                    }) as Promise<File>[]\n                ))\n            );\n\n            if (resp.data.diff.length) {\n                time = resp.data.diff.slice(-1)[0].updationTime;\n            }\n            setFiles(\n                sortFiles(\n                    mergeMetadata(\n                        [...(files || []), ...decryptedFiles].filter(\n                            (item) => !item.isDeleted\n                        )\n                    )\n                )\n            );\n        } while (resp.data.hasMore);\n        return decryptedFiles;\n    } catch (e) {\n        logError(e, 'Get files failed');\n    }\n};\n\nconst removeDeletedCollectionFiles = async (\n    collections: Collection[],\n    files: File[]\n) => {\n    const syncedCollectionIds = new Set<number>();\n    for (const collection of collections) {\n        syncedCollectionIds.add(collection.id);\n    }\n    files = files.filter((file) => syncedCollectionIds.has(file.collectionID));\n    return files;\n};\n\nexport const trashFiles = async (filesToTrash: File[]) => {\n    try {\n        const token = getToken();\n        if (!token) {\n            return;\n        }\n        const trashRequest: TrashRequest = {\n            items: filesToTrash.map((file) => ({\n                fileID: file.id,\n                collectionID: file.collectionID,\n            })),\n        };\n        await HTTPService.post(`${ENDPOINT}/files/trash`, trashRequest, null, {\n            'X-Auth-Token': token,\n        });\n    } catch (e) {\n        logError(e, 'trash file failed');\n        throw e;\n    }\n};\n\nexport const deleteFromTrash = async (filesToDelete: number[]) => {\n    try {\n        const token = getToken();\n        if (!token) {\n            return;\n        }\n        await HTTPService.post(\n            `${ENDPOINT}/trash/delete`,\n            { fileIDs: filesToDelete },\n            null,\n            {\n                'X-Auth-Token': token,\n            }\n        );\n    } catch (e) {\n        logError(e, 'delete from trash failed');\n        throw e;\n    }\n};\n\nexport const updateMagicMetadata = async (files: File[]) => {\n    const token = getToken();\n    if (!token) {\n        return;\n    }\n    const reqBody: UpdateMagicMetadataRequest = { metadataList: [] };\n    const worker = await new CryptoWorker();\n    for (const file of files) {\n        const { file: encryptedMagicMetadata }: EncryptionResult =\n            await worker.encryptMetadata(file.magicMetadata.data, file.key);\n        reqBody.metadataList.push({\n            id: file.id,\n            magicMetadata: {\n                version: file.magicMetadata.version,\n                count: file.magicMetadata.count,\n                data: encryptedMagicMetadata.encryptedData as unknown as string,\n                header: encryptedMagicMetadata.decryptionHeader,\n            },\n        });\n    }\n    await HTTPService.put(`${ENDPOINT}/files/magic-metadata`, reqBody, null, {\n        'X-Auth-Token': token,\n    });\n    return files.map(\n        (file): File => ({\n            ...file,\n            magicMetadata: {\n                ...file.magicMetadata,\n                version: file.magicMetadata.version + 1,\n            },\n        })\n    );\n};\n\nexport const updatePublicMagicMetadata = async (files: File[]) => {\n    const token = getToken();\n    if (!token) {\n        return;\n    }\n    const reqBody: UpdateMagicMetadataRequest = { metadataList: [] };\n    const worker = await new CryptoWorker();\n    for (const file of files) {\n        const { file: encryptedPubMagicMetadata }: EncryptionResult =\n            await worker.encryptMetadata(file.pubMagicMetadata.data, file.key);\n        reqBody.metadataList.push({\n            id: file.id,\n            magicMetadata: {\n                version: file.pubMagicMetadata.version,\n                count: file.pubMagicMetadata.count,\n                data: encryptedPubMagicMetadata.encryptedData as unknown as string,\n                header: encryptedPubMagicMetadata.decryptionHeader,\n            },\n        });\n    }\n    await HTTPService.put(\n        `${ENDPOINT}/files/public-magic-metadata`,\n        reqBody,\n        null,\n        {\n            'X-Auth-Token': token,\n        }\n    );\n    return files.map(\n        (file): File => ({\n            ...file,\n            pubMagicMetadata: {\n                ...file.pubMagicMetadata,\n                version: file.pubMagicMetadata.version + 1,\n            },\n        })\n    );\n};\n","import JSZip from 'jszip';\nimport { fileExtensionWithDot } from 'utils/file';\n\nclass MotionPhoto {\n    image: Uint8Array;\n    video: Uint8Array;\n    imageNameTitle: String;\n    videoNameTitle: String;\n}\n\nexport const decodeMotionPhoto = async (\n    zipBlob: Blob,\n    originalName: string\n) => {\n    const zip = await JSZip.loadAsync(zipBlob, { createFolders: true });\n\n    const motionPhoto = new MotionPhoto();\n    for (const zipFilename in zip.files) {\n        if (zipFilename.startsWith('image')) {\n            motionPhoto.imageNameTitle =\n                originalName + fileExtensionWithDot(zipFilename);\n            motionPhoto.image = await zip.files[zipFilename].async(\n                'uint8array'\n            );\n        } else if (zipFilename.startsWith('video')) {\n            motionPhoto.videoNameTitle =\n                originalName + fileExtensionWithDot(zipFilename);\n            motionPhoto.video = await zip.files[zipFilename].async(\n                'uint8array'\n            );\n        }\n    }\n    return motionPhoto;\n};\n","import exifr from 'exifr';\nimport { logError } from 'utils/sentry';\n\nimport { NULL_LOCATION, Location } from './metadataService';\nimport { FileTypeInfo } from './readFileService';\n\nconst EXIF_TAGS_NEEDED = [\n    'DateTimeOriginal',\n    'CreateDate',\n    'ModifyDate',\n    'GPSLatitude',\n    'GPSLongitude',\n    'GPSLatitudeRef',\n    'GPSLongitudeRef',\n];\ninterface Exif {\n    DateTimeOriginal?: Date;\n    CreateDate?: Date;\n    ModifyDate?: Date;\n    GPSLatitude?: number;\n    GPSLongitude?: number;\n    GPSLatitudeRef?: number;\n    GPSLongitudeRef?: number;\n}\ninterface ParsedEXIFData {\n    location: Location;\n    creationTime: number;\n}\n\nexport async function getExifData(\n    receivedFile: globalThis.File,\n    fileTypeInfo: FileTypeInfo\n): Promise<ParsedEXIFData> {\n    const nullExifData: ParsedEXIFData = {\n        location: NULL_LOCATION,\n        creationTime: null,\n    };\n    try {\n        const exifData = await getRawExif(receivedFile, fileTypeInfo);\n        if (!exifData) {\n            return nullExifData;\n        }\n        const parsedEXIFData = {\n            location: getEXIFLocation(exifData),\n            creationTime: getUNIXTime(\n                exifData.DateTimeOriginal ??\n                    exifData.CreateDate ??\n                    exifData.ModifyDate\n            ),\n        };\n        return parsedEXIFData;\n    } catch (e) {\n        logError(e, 'getExifData failed');\n        return nullExifData;\n    }\n}\n\nexport async function getRawExif(\n    receivedFile: File,\n    fileTypeInfo: FileTypeInfo\n) {\n    let exifData: Exif;\n    try {\n        exifData = await exifr.parse(receivedFile, EXIF_TAGS_NEEDED);\n    } catch (e) {\n        logError(e, 'file missing exif data ', {\n            fileType: fileTypeInfo.exactType,\n        });\n        // ignore exif parsing errors\n    }\n    return exifData;\n}\n\nexport function getUNIXTime(dateTime: Date) {\n    try {\n        if (!dateTime) {\n            return null;\n        }\n        const unixTime = dateTime.getTime() * 1000;\n        if (unixTime <= 0) {\n            return null;\n        } else {\n            return unixTime;\n        }\n    } catch (e) {\n        logError(e, 'getUNIXTime failed', { dateTime });\n    }\n}\n\nfunction getEXIFLocation(exifData): Location {\n    if (!exifData.latitude || !exifData.longitude) {\n        return NULL_LOCATION;\n    }\n    return { latitude: exifData.latitude, longitude: exifData.longitude };\n}\n","import { FILE_TYPE } from 'services/fileService';\nimport { logError } from 'utils/sentry';\nimport { getExifData } from './exifService';\nimport { FileTypeInfo } from './readFileService';\nimport { MetadataObject } from './uploadService';\n\nexport interface Location {\n    latitude: number;\n    longitude: number;\n}\n\nexport interface ParsedMetaDataJSON {\n    creationTime: number;\n    modificationTime: number;\n    latitude: number;\n    longitude: number;\n}\ninterface ParsedMetaDataJSONWithTitle {\n    title: string;\n    parsedMetaDataJSON: ParsedMetaDataJSON;\n}\n\nexport const NULL_LOCATION: Location = { latitude: null, longitude: null };\n\nconst NULL_PARSED_METADATA_JSON: ParsedMetaDataJSON = {\n    creationTime: null,\n    modificationTime: null,\n    ...NULL_LOCATION,\n};\n\nexport async function extractMetadata(\n    receivedFile: globalThis.File,\n    fileTypeInfo: FileTypeInfo\n) {\n    let exifData = null;\n    if (fileTypeInfo.fileType === FILE_TYPE.IMAGE) {\n        exifData = await getExifData(receivedFile, fileTypeInfo);\n    }\n\n    const extractedMetadata: MetadataObject = {\n        title: receivedFile.name,\n        creationTime:\n            exifData?.creationTime ?? receivedFile.lastModified * 1000,\n        modificationTime: receivedFile.lastModified * 1000,\n        latitude: exifData?.location?.latitude,\n        longitude: exifData?.location?.longitude,\n        fileType: fileTypeInfo.fileType,\n    };\n    return extractedMetadata;\n}\n\nexport const getMetadataMapKey = (collectionID: number, title: string) =>\n    `${collectionID}_${title}`;\n\nexport async function parseMetadataJSON(receivedFile: globalThis.File) {\n    try {\n        const metadataJSON: object = await new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onabort = () => reject(Error('file reading was aborted'));\n            reader.onerror = () => reject(Error('file reading has failed'));\n            reader.onload = () => {\n                const result =\n                    typeof reader.result !== 'string'\n                        ? new TextDecoder().decode(reader.result)\n                        : reader.result;\n                resolve(JSON.parse(result));\n            };\n            reader.readAsText(receivedFile);\n        });\n\n        const parsedMetaDataJSON: ParsedMetaDataJSON =\n            NULL_PARSED_METADATA_JSON;\n        if (!metadataJSON || !metadataJSON['title']) {\n            return;\n        }\n\n        const title = metadataJSON['title'];\n        if (\n            metadataJSON['photoTakenTime'] &&\n            metadataJSON['photoTakenTime']['timestamp']\n        ) {\n            parsedMetaDataJSON.creationTime =\n                metadataJSON['photoTakenTime']['timestamp'] * 1000000;\n        } else if (\n            metadataJSON['creationTime'] &&\n            metadataJSON['creationTime']['timestamp']\n        ) {\n            parsedMetaDataJSON.creationTime =\n                metadataJSON['creationTime']['timestamp'] * 1000000;\n        }\n        if (\n            metadataJSON['modificationTime'] &&\n            metadataJSON['modificationTime']['timestamp']\n        ) {\n            parsedMetaDataJSON.modificationTime =\n                metadataJSON['modificationTime']['timestamp'] * 1000000;\n        }\n        let locationData: Location = NULL_LOCATION;\n        if (\n            metadataJSON['geoData'] &&\n            (metadataJSON['geoData']['latitude'] !== 0.0 ||\n                metadataJSON['geoData']['longitude'] !== 0.0)\n        ) {\n            locationData = metadataJSON['geoData'];\n        } else if (\n            metadataJSON['geoDataExif'] &&\n            (metadataJSON['geoDataExif']['latitude'] !== 0.0 ||\n                metadataJSON['geoDataExif']['longitude'] !== 0.0)\n        ) {\n            locationData = metadataJSON['geoDataExif'];\n        }\n        if (locationData !== null) {\n            parsedMetaDataJSON.latitude = locationData.latitude;\n            parsedMetaDataJSON.longitude = locationData.longitude;\n        }\n        return { title, parsedMetaDataJSON } as ParsedMetaDataJSONWithTitle;\n    } catch (e) {\n        logError(e, 'parseMetadataJSON failed');\n        // ignore\n    }\n}\n","import {\n    FILE_TYPE,\n    FORMAT_MISSED_BY_FILE_TYPE_LIB,\n} from 'services/fileService';\nimport { logError } from 'utils/sentry';\nimport { FILE_READER_CHUNK_SIZE, MULTIPART_PART_SIZE } from './uploadService';\nimport FileType from 'file-type/browser';\nimport { CustomError } from 'utils/common/errorUtil';\n\nconst TYPE_VIDEO = 'video';\nconst TYPE_IMAGE = 'image';\nconst EDITED_FILE_SUFFIX = '-edited';\nconst CHUNK_SIZE_FOR_TYPE_DETECTION = 4100;\n\nexport async function getFileData(worker, file: globalThis.File) {\n    if (file.size > MULTIPART_PART_SIZE) {\n        return getFileStream(worker, file, FILE_READER_CHUNK_SIZE);\n    } else {\n        return await worker.getUint8ArrayView(file);\n    }\n}\n\nexport interface FileTypeInfo {\n    fileType: FILE_TYPE;\n    exactType: string;\n}\n\nexport async function getFileType(\n    worker,\n    receivedFile: globalThis.File\n): Promise<FileTypeInfo> {\n    try {\n        let fileType: FILE_TYPE;\n        const mimeType = await getMimeType(worker, receivedFile);\n        const typeParts = mimeType?.split('/');\n        if (typeParts?.length !== 2) {\n            throw Error(CustomError.TYPE_DETECTION_FAILED);\n        }\n        switch (typeParts[0]) {\n            case TYPE_IMAGE:\n                fileType = FILE_TYPE.IMAGE;\n                break;\n            case TYPE_VIDEO:\n                fileType = FILE_TYPE.VIDEO;\n                break;\n            default:\n                fileType = FILE_TYPE.OTHERS;\n        }\n        return { fileType, exactType: typeParts[1] };\n    } catch (e) {\n        const fileFormat = receivedFile.name.split('.').pop();\n        const formatMissedByTypeDetection = FORMAT_MISSED_BY_FILE_TYPE_LIB.find(\n            (a) => a.exactType === fileFormat\n        );\n        if (formatMissedByTypeDetection) {\n            return formatMissedByTypeDetection;\n        }\n        logError(e, CustomError.TYPE_DETECTION_FAILED, {\n            fileFormat,\n        });\n        return { fileType: FILE_TYPE.OTHERS, exactType: fileFormat };\n    }\n}\n\n/*\n    Get the original file name for edited file to associate it to original file's metadataJSON file \n    as edited file doesn't have their own metadata file\n*/\nexport function getFileOriginalName(file: globalThis.File) {\n    let originalName: string = null;\n\n    const isEditedFile = file.name.endsWith(EDITED_FILE_SUFFIX);\n    if (isEditedFile) {\n        originalName = file.name.slice(0, -1 * EDITED_FILE_SUFFIX.length);\n    } else {\n        originalName = file.name;\n    }\n    return originalName;\n}\n\nasync function getMimeType(worker, file: globalThis.File) {\n    const fileChunkBlob = file.slice(0, CHUNK_SIZE_FOR_TYPE_DETECTION);\n    return getMimeTypeFromBlob(worker, fileChunkBlob);\n}\n\nexport async function getMimeTypeFromBlob(worker, fileBlob: Blob) {\n    try {\n        const initialFiledata = await worker.getUint8ArrayView(fileBlob);\n        const result = await FileType.fromBuffer(initialFiledata);\n        return result.mime;\n    } catch (e) {\n        throw Error(CustomError.TYPE_DETECTION_FAILED);\n    }\n}\n\nfunction getFileStream(worker, file: globalThis.File, chunkSize: number) {\n    const fileChunkReader = fileChunkReaderMaker(worker, file, chunkSize);\n\n    const stream = new ReadableStream<Uint8Array>({\n        async pull(controller: ReadableStreamDefaultController) {\n            const chunk = await fileChunkReader.next();\n            if (chunk.done) {\n                controller.close();\n            } else {\n                controller.enqueue(chunk.value);\n            }\n        },\n    });\n    const chunkCount = Math.ceil(file.size / chunkSize);\n    return {\n        stream,\n        chunkCount,\n    };\n}\n\nasync function* fileChunkReaderMaker(\n    worker,\n    file: globalThis.File,\n    chunkSize: number\n) {\n    let offset = 0;\n    while (offset < file.size) {\n        const blob = file.slice(offset, chunkSize + offset);\n        const fileChunk = await worker.getUint8ArrayView(blob);\n        yield fileChunk;\n        offset += chunkSize;\n    }\n    return null;\n}\n\nexport async function getUint8ArrayView(\n    reader: FileReader,\n    file: Blob\n): Promise<Uint8Array> {\n    try {\n        return await new Promise((resolve, reject) => {\n            reader.onabort = () => reject(Error('file reading was aborted'));\n            reader.onerror = () => reject(Error('file reading has failed'));\n            reader.onload = () => {\n                // Do whatever you want with the file contents\n                const result =\n                    typeof reader.result === 'string'\n                        ? new TextEncoder().encode(reader.result)\n                        : new Uint8Array(reader.result);\n                resolve(result);\n            };\n            reader.readAsArrayBuffer(file);\n        });\n    } catch (e) {\n        logError(e, 'error reading file to byte-array');\n        throw e;\n    }\n}\n","export const BLACK_THUMBNAIL_BASE64 = `/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQE\nBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQ\nEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARC\nACWASwDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUF\nBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk\n6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztL\nW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAA\nAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVY\nnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImK\nkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oAD\nAMBAAIRAxEAPwD/AD/6ACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKA\nCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACg\nAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAC\ngAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAo\nAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACg\nAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACg\nAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKA\nCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKA\nCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA\nKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACg\nAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAo\nAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKA\nCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAK\nACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA\nKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAo\nAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAo\nAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD/9k=`;\n","import { CustomError } from 'utils/common/errorUtil';\n\ninterface RequestQueueItem {\n    request: (canceller?: RequestCanceller) => Promise<any>;\n    successCallback: (response: any) => void;\n    failureCallback: (error: Error) => void;\n    isCanceled: { status: boolean };\n    canceller: { exec: () => void };\n}\n\nexport interface RequestCanceller {\n    exec: () => void;\n}\n\nexport default class QueueProcessor<T> {\n    private requestQueue: RequestQueueItem[] = [];\n\n    private requestInProcessing = 0;\n\n    constructor(private maxParallelProcesses: number) {}\n\n    public queueUpRequest(\n        request: (canceller?: RequestCanceller) => Promise<T>\n    ) {\n        const isCanceled = { status: false };\n        const canceller: RequestCanceller = {\n            exec: () => {\n                isCanceled.status = true;\n            },\n        };\n\n        const promise = new Promise<T>((resolve, reject) => {\n            this.requestQueue.push({\n                request,\n                successCallback: resolve,\n                failureCallback: reject,\n                isCanceled,\n                canceller,\n            });\n            this.pollQueue();\n        });\n\n        return { promise, canceller };\n    }\n\n    async pollQueue() {\n        if (this.requestInProcessing < this.maxParallelProcesses) {\n            this.requestInProcessing++;\n            await this.processQueue();\n            this.requestInProcessing--;\n        }\n    }\n\n    public async processQueue() {\n        while (this.requestQueue.length > 0) {\n            const queueItem = this.requestQueue.pop();\n            let response = null;\n\n            if (queueItem.isCanceled.status) {\n                queueItem.failureCallback(Error(CustomError.REQUEST_CANCELLED));\n            } else {\n                try {\n                    response = await queueItem.request(queueItem.canceller);\n                    queueItem.successCallback(response);\n                } catch (e) {\n                    queueItem.failureCallback(e);\n                }\n            }\n        }\n    }\n}\n","import { createFFmpeg, FFmpeg } from '@ffmpeg/ffmpeg';\nimport { CustomError } from 'utils/common/errorUtil';\nimport { logError } from 'utils/sentry';\nimport QueueProcessor from './upload/queueProcessor';\nimport { getUint8ArrayView } from './upload/readFileService';\n\nclass FFmpegService {\n    private ffmpeg: FFmpeg = null;\n    private isLoading = null;\n\n    private generateThumbnailProcessor = new QueueProcessor<Uint8Array>(1);\n    async init() {\n        try {\n            this.ffmpeg = createFFmpeg({\n                corePath: '/js/ffmpeg/ffmpeg-core.js',\n            });\n            this.isLoading = this.ffmpeg.load();\n            await this.isLoading;\n            this.isLoading = null;\n        } catch (e) {\n            logError(e, 'ffmpeg load failed');\n            this.ffmpeg = null;\n            this.isLoading = null;\n            throw e;\n        }\n    }\n\n    async generateThumbnail(file: File) {\n        if (!this.ffmpeg) {\n            await this.init();\n        }\n        if (this.isLoading) {\n            await this.isLoading;\n        }\n        const response = this.generateThumbnailProcessor.queueUpRequest(\n            generateThumbnailHelper.bind(null, this.ffmpeg, file)\n        );\n        try {\n            return await response.promise;\n        } catch (e) {\n            if (e.message === CustomError.REQUEST_CANCELLED) {\n                // ignore\n                return null;\n            } else {\n                logError(e, 'ffmpeg thumbnail generation failed');\n                throw e;\n            }\n        }\n    }\n}\n\nasync function generateThumbnailHelper(ffmpeg: FFmpeg, file: File) {\n    try {\n        const inputFileName = `${Date.now().toString()}-${file.name}`;\n        const thumbFileName = `${Date.now().toString()}-thumb.jpeg`;\n        ffmpeg.FS(\n            'writeFile',\n            inputFileName,\n            await getUint8ArrayView(new FileReader(), file)\n        );\n        let seekTime = 1.0;\n        let thumb = null;\n        while (seekTime > 0) {\n            try {\n                await ffmpeg.run(\n                    '-i',\n                    inputFileName,\n                    '-ss',\n                    `00:00:0${seekTime.toFixed(3)}`,\n                    '-vframes',\n                    '1',\n                    '-vf',\n                    'scale=-1:720',\n                    thumbFileName\n                );\n                thumb = ffmpeg.FS('readFile', thumbFileName);\n                ffmpeg.FS('unlink', thumbFileName);\n                break;\n            } catch (e) {\n                seekTime = Number((seekTime / 10).toFixed(3));\n            }\n        }\n        ffmpeg.FS('unlink', inputFileName);\n        return thumb;\n    } catch (e) {\n        logError(e, 'ffmpeg thumbnail generation failed');\n        throw e;\n    }\n}\n\nexport default new FFmpegService();\n","import { FILE_TYPE } from 'services/fileService';\nimport { CustomError, errorWithContext } from 'utils/common/errorUtil';\nimport { logError } from 'utils/sentry';\nimport { BLACK_THUMBNAIL_BASE64 } from '../../../public/images/black-thumbnail-b64';\nimport FFmpegService from 'services/ffmpegService';\nimport { convertToHumanReadable } from 'utils/billingUtil';\nimport { isFileHEIC } from 'utils/file';\nimport { FileTypeInfo } from './readFileService';\n\nconst MAX_THUMBNAIL_DIMENSION = 720;\nconst MIN_COMPRESSION_PERCENTAGE_SIZE_DIFF = 10;\nexport const MAX_THUMBNAIL_SIZE = 100 * 1024;\nconst MIN_QUALITY = 0.5;\nconst MAX_QUALITY = 0.7;\n\nconst WAIT_TIME_THUMBNAIL_GENERATION = 10 * 1000;\n\ninterface Dimension {\n    width: number;\n    height: number;\n}\n\nexport async function generateThumbnail(\n    worker,\n    file: globalThis.File,\n    fileTypeInfo: FileTypeInfo\n): Promise<{ thumbnail: Uint8Array; hasStaticThumbnail: boolean }> {\n    try {\n        let hasStaticThumbnail = false;\n        let canvas = document.createElement('canvas');\n        let thumbnail: Uint8Array;\n        try {\n            if (fileTypeInfo.fileType === FILE_TYPE.IMAGE) {\n                const isHEIC = isFileHEIC(fileTypeInfo.exactType);\n                canvas = await generateImageThumbnail(worker, file, isHEIC);\n            } else {\n                try {\n                    const thumb = await FFmpegService.generateThumbnail(file);\n                    const dummyImageFile = new File([thumb], file.name);\n                    canvas = await generateImageThumbnail(\n                        worker,\n                        dummyImageFile,\n                        false\n                    );\n                } catch (e) {\n                    logError(e, 'failed to generate thumbnail using ffmpeg', {\n                        fileFormat: fileTypeInfo.exactType,\n                    });\n                    canvas = await generateVideoThumbnail(file);\n                }\n            }\n            const thumbnailBlob = await thumbnailCanvasToBlob(canvas);\n            thumbnail = await worker.getUint8ArrayView(thumbnailBlob);\n            if (thumbnail.length === 0) {\n                throw Error('EMPTY THUMBNAIL');\n            }\n        } catch (e) {\n            logError(e, 'uploading static thumbnail', {\n                fileFormat: fileTypeInfo.exactType,\n            });\n            thumbnail = Uint8Array.from(atob(BLACK_THUMBNAIL_BASE64), (c) =>\n                c.charCodeAt(0)\n            );\n            hasStaticThumbnail = true;\n        }\n        return { thumbnail, hasStaticThumbnail };\n    } catch (e) {\n        logError(e, 'Error generating static thumbnail');\n        throw e;\n    }\n}\n\nexport async function generateImageThumbnail(\n    worker,\n    file: globalThis.File,\n    isHEIC: boolean\n) {\n    const canvas = document.createElement('canvas');\n    const canvasCTX = canvas.getContext('2d');\n\n    let imageURL = null;\n    let timeout = null;\n\n    if (isHEIC) {\n        file = new globalThis.File(\n            [await worker.convertHEIC2JPEG(file)],\n            null,\n            null\n        );\n    }\n    let image = new Image();\n    imageURL = URL.createObjectURL(file);\n    image.setAttribute('src', imageURL);\n    await new Promise((resolve, reject) => {\n        image.onload = () => {\n            try {\n                const imageDimension = {\n                    width: image.width,\n                    height: image.height,\n                };\n                const thumbnailDimension = calculateThumbnailDimension(\n                    imageDimension,\n                    MAX_THUMBNAIL_DIMENSION\n                );\n                canvas.width = thumbnailDimension.width;\n                canvas.height = thumbnailDimension.height;\n                canvasCTX.drawImage(\n                    image,\n                    0,\n                    0,\n                    thumbnailDimension.width,\n                    thumbnailDimension.height\n                );\n                image = null;\n                clearTimeout(timeout);\n                resolve(null);\n            } catch (e) {\n                const err = errorWithContext(\n                    e,\n                    `${CustomError.THUMBNAIL_GENERATION_FAILED} err: ${e}`\n                );\n                reject(err);\n            }\n        };\n        timeout = setTimeout(\n            () => reject(Error(CustomError.WAIT_TIME_EXCEEDED)),\n            WAIT_TIME_THUMBNAIL_GENERATION\n        );\n    });\n    return canvas;\n}\n\nexport async function generateVideoThumbnail(file: globalThis.File) {\n    const canvas = document.createElement('canvas');\n    const canvasCTX = canvas.getContext('2d');\n\n    let videoURL = null;\n    let timeout = null;\n\n    await new Promise((resolve, reject) => {\n        let video = document.createElement('video');\n        videoURL = URL.createObjectURL(file);\n        video.addEventListener('loadeddata', function () {\n            try {\n                if (!video) {\n                    throw Error('video load failed');\n                }\n                const videoDimension = {\n                    width: video.videoWidth,\n                    height: video.videoHeight,\n                };\n                const thumbnailDimension = calculateThumbnailDimension(\n                    videoDimension,\n                    MAX_THUMBNAIL_DIMENSION\n                );\n                canvas.width = thumbnailDimension.width;\n                canvas.height = thumbnailDimension.height;\n                canvasCTX.drawImage(\n                    video,\n                    0,\n                    0,\n                    thumbnailDimension.width,\n                    thumbnailDimension.height\n                );\n                video = null;\n                clearTimeout(timeout);\n                resolve(null);\n            } catch (e) {\n                const err = Error(\n                    `${CustomError.THUMBNAIL_GENERATION_FAILED} err: ${e}`\n                );\n                logError(e, CustomError.THUMBNAIL_GENERATION_FAILED);\n                reject(err);\n            }\n        });\n        video.preload = 'metadata';\n        video.src = videoURL;\n        timeout = setTimeout(\n            () => reject(Error(CustomError.WAIT_TIME_EXCEEDED)),\n            WAIT_TIME_THUMBNAIL_GENERATION\n        );\n    });\n    return canvas;\n}\n\nasync function thumbnailCanvasToBlob(canvas: HTMLCanvasElement) {\n    let thumbnailBlob: Blob = null;\n    let prevSize = Number.MAX_SAFE_INTEGER;\n    let quality = MAX_QUALITY;\n\n    do {\n        if (thumbnailBlob) {\n            prevSize = thumbnailBlob.size;\n        }\n        thumbnailBlob = await new Promise((resolve) => {\n            canvas.toBlob(\n                function (blob) {\n                    resolve(blob);\n                },\n                'image/jpeg',\n                quality\n            );\n        });\n        thumbnailBlob = thumbnailBlob ?? new Blob([]);\n        quality -= 0.1;\n    } while (\n        quality >= MIN_QUALITY &&\n        thumbnailBlob.size > MAX_THUMBNAIL_SIZE &&\n        percentageSizeDiff(thumbnailBlob.size, prevSize) >=\n            MIN_COMPRESSION_PERCENTAGE_SIZE_DIFF\n    );\n    if (thumbnailBlob.size > MAX_THUMBNAIL_SIZE) {\n        logError(\n            Error('thumbnail_too_large'),\n            'thumbnail greater than max limit',\n            { thumbnailSize: convertToHumanReadable(thumbnailBlob.size) }\n        );\n    }\n\n    return thumbnailBlob;\n}\n\nfunction percentageSizeDiff(\n    newThumbnailSize: number,\n    oldThumbnailSize: number\n) {\n    return ((oldThumbnailSize - newThumbnailSize) * 100) / oldThumbnailSize;\n}\n\n// method to calculate new size of image for limiting it to maximum width and height, maintaining aspect ratio\n// returns {0,0} for invalid inputs\nfunction calculateThumbnailDimension(\n    originalDimension: Dimension,\n    maxDimension: number\n): Dimension {\n    if (originalDimension.height === 0 || originalDimension.width === 0) {\n        return { width: 0, height: 0 };\n    }\n    const widthScaleFactor = maxDimension / originalDimension.width;\n    const heightScaleFactor = maxDimension / originalDimension.height;\n    const scaleFactor = Math.min(widthScaleFactor, heightScaleFactor);\n    const thumbnailDimension = {\n        width: Math.round(originalDimension.width * scaleFactor),\n        height: Math.round(originalDimension.height * scaleFactor),\n    };\n    if (thumbnailDimension.width === 0 || thumbnailDimension.height === 0) {\n        return { width: 0, height: 0 };\n    }\n    return thumbnailDimension;\n}\n","import { ProgressUpdater } from 'components/pages/gallery/Upload';\nimport { UPLOAD_STAGES } from './uploadManager';\n\nexport const RANDOM_PERCENTAGE_PROGRESS_FOR_PUT = () => 90 + 10 * Math.random();\n\nclass UIService {\n    private perFileProgress: number;\n    private filesUploaded: number;\n    private totalFileCount: number;\n    private fileProgress: Map<string, number>;\n    private uploadResult: Map<string, number>;\n    private progressUpdater: ProgressUpdater;\n\n    init(progressUpdater: ProgressUpdater) {\n        this.progressUpdater = progressUpdater;\n    }\n\n    reset(count: number) {\n        this.setTotalFileCount(count);\n        this.filesUploaded = 0;\n        this.fileProgress = new Map<string, number>();\n        this.uploadResult = new Map<string, number>();\n        this.updateProgressBarUI();\n    }\n\n    setTotalFileCount(count: number) {\n        this.totalFileCount = count;\n        this.perFileProgress = 100 / this.totalFileCount;\n    }\n\n    setFileProgress(filename: string, progress: number) {\n        this.fileProgress.set(filename, progress);\n        this.updateProgressBarUI();\n    }\n\n    setUploadStage(stage: UPLOAD_STAGES) {\n        this.progressUpdater.setUploadStage(stage);\n    }\n\n    setPercentComplete(percent: number) {\n        this.progressUpdater.setPercentComplete(percent);\n    }\n\n    increaseFileUploaded() {\n        this.filesUploaded++;\n        this.updateProgressBarUI();\n    }\n\n    moveFileToResultList(filename: string) {\n        this.uploadResult.set(filename, this.fileProgress.get(filename));\n        this.fileProgress.delete(filename);\n        this.updateProgressBarUI();\n    }\n\n    updateProgressBarUI() {\n        const {\n            setPercentComplete,\n            setFileCounter,\n            setFileProgress,\n            setUploadResult,\n        } = this.progressUpdater;\n        setFileCounter({\n            finished: this.filesUploaded,\n            total: this.totalFileCount,\n        });\n        let percentComplete = this.perFileProgress * this.uploadResult.size;\n        if (this.fileProgress) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            for (const [_, progress] of this.fileProgress) {\n                // filter  negative indicator values during percentComplete calculation\n                if (progress < 0) {\n                    continue;\n                }\n                percentComplete += (this.perFileProgress * progress) / 100;\n            }\n        }\n        setPercentComplete(percentComplete);\n        setFileProgress(this.fileProgress);\n        setUploadResult(this.uploadResult);\n    }\n\n    trackUploadProgress(\n        filename: string,\n        percentPerPart = RANDOM_PERCENTAGE_PROGRESS_FOR_PUT(),\n        index = 0\n    ) {\n        const cancel = { exec: null };\n        let timeout = null;\n        const resetTimeout = () => {\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(() => cancel.exec(), 30 * 1000);\n        };\n        return {\n            cancel,\n            onUploadProgress: (event) => {\n                filename &&\n                    this.fileProgress.set(\n                        filename,\n                        Math.min(\n                            Math.round(\n                                percentPerPart * index +\n                                    (percentPerPart * event.loaded) /\n                                        event.total\n                            ),\n                            98\n                        )\n                    );\n                this.updateProgressBarUI();\n                if (event.loaded === event.total) {\n                    clearTimeout(timeout);\n                } else {\n                    resetTimeout();\n                }\n            },\n        };\n    }\n}\n\nexport default new UIService();\n","import HTTPService from 'services/HTTPService';\nimport { getEndpoint } from 'utils/common/apiUtil';\nimport { getToken } from 'utils/common/key';\nimport { logError } from 'utils/sentry';\nimport { UploadFile, UploadURL } from './uploadService';\nimport { File } from '../fileService';\nimport { CustomError, handleUploadError } from 'utils/common/errorUtil';\nimport { retryAsyncFunction } from 'utils/network';\nimport { MultipartUploadURLs } from './multiPartUploadService';\n\nconst ENDPOINT = getEndpoint();\nconst MAX_URL_REQUESTS = 50;\n\nclass UploadHttpClient {\n    private uploadURLFetchInProgress = null;\n\n    async uploadFile(uploadFile: UploadFile): Promise<File> {\n        try {\n            const token = getToken();\n            if (!token) {\n                return;\n            }\n            const response = await retryAsyncFunction(\n                () =>\n                    HTTPService.post(`${ENDPOINT}/files`, uploadFile, null, {\n                        'X-Auth-Token': token,\n                    }),\n                handleUploadError\n            );\n            return response.data;\n        } catch (e) {\n            logError(e, 'upload Files Failed');\n            throw e;\n        }\n    }\n\n    async fetchUploadURLs(count: number, urlStore: UploadURL[]): Promise<void> {\n        try {\n            if (!this.uploadURLFetchInProgress) {\n                try {\n                    const token = getToken();\n                    if (!token) {\n                        return;\n                    }\n                    this.uploadURLFetchInProgress = HTTPService.get(\n                        `${ENDPOINT}/files/upload-urls`,\n                        {\n                            count: Math.min(MAX_URL_REQUESTS, count * 2),\n                        },\n                        { 'X-Auth-Token': token }\n                    );\n                    const response = await this.uploadURLFetchInProgress;\n                    urlStore.push(...response.data['urls']);\n                } finally {\n                    this.uploadURLFetchInProgress = null;\n                }\n            }\n            return this.uploadURLFetchInProgress;\n        } catch (e) {\n            logError(e, 'fetch upload-url failed ');\n            throw e;\n        }\n    }\n\n    async fetchMultipartUploadURLs(\n        count: number\n    ): Promise<MultipartUploadURLs> {\n        try {\n            const token = getToken();\n            if (!token) {\n                return;\n            }\n            const response = await HTTPService.get(\n                `${ENDPOINT}/files/multipart-upload-urls`,\n                {\n                    count,\n                },\n                { 'X-Auth-Token': token }\n            );\n\n            return response.data['urls'];\n        } catch (e) {\n            logError(e, 'fetch multipart-upload-url failed');\n            throw e;\n        }\n    }\n\n    async putFile(\n        fileUploadURL: UploadURL,\n        file: Uint8Array,\n        progressTracker\n    ): Promise<string> {\n        try {\n            await retryAsyncFunction(() =>\n                HTTPService.put(\n                    fileUploadURL.url,\n                    file,\n                    null,\n                    null,\n                    progressTracker\n                )\n            );\n            return fileUploadURL.objectKey;\n        } catch (e) {\n            logError(e, 'putFile to dataStore failed ');\n            throw e;\n        }\n    }\n\n    async putFilePart(\n        partUploadURL: string,\n        filePart: Uint8Array,\n        progressTracker\n    ) {\n        try {\n            const response = await retryAsyncFunction(async () => {\n                const resp = await HTTPService.put(\n                    partUploadURL,\n                    filePart,\n                    null,\n                    null,\n                    progressTracker\n                );\n                if (!resp?.headers?.etag) {\n                    const err = Error(CustomError.ETAG_MISSING);\n                    logError(err, 'putFile in parts failed');\n                    throw err;\n                }\n                return resp;\n            });\n            return response.headers.etag as string;\n        } catch (e) {\n            logError(e, 'put filePart failed');\n            throw e;\n        }\n    }\n\n    async completeMultipartUpload(completeURL: string, reqBody: any) {\n        try {\n            await retryAsyncFunction(() =>\n                HTTPService.post(completeURL, reqBody, null, {\n                    'content-type': 'text/xml',\n                })\n            );\n        } catch (e) {\n            logError(e, 'put file in parts failed');\n            throw e;\n        }\n    }\n}\n\nexport default new UploadHttpClient();\n","import { DataStream, EncryptionResult, isDataStream } from './uploadService';\n\nasync function encryptFileStream(worker, fileData: DataStream) {\n    const { stream, chunkCount } = fileData;\n    const fileStreamReader = stream.getReader();\n    const { key, decryptionHeader, pushState } =\n        await worker.initChunkEncryption();\n    const ref = { pullCount: 1 };\n    const encryptedFileStream = new ReadableStream({\n        async pull(controller) {\n            const { value } = await fileStreamReader.read();\n            const encryptedFileChunk = await worker.encryptFileChunk(\n                value,\n                pushState,\n                ref.pullCount === chunkCount\n            );\n            controller.enqueue(encryptedFileChunk);\n            if (ref.pullCount === chunkCount) {\n                controller.close();\n            }\n            ref.pullCount++;\n        },\n    });\n    return {\n        key,\n        file: {\n            decryptionHeader,\n            encryptedData: { stream: encryptedFileStream, chunkCount },\n        },\n    };\n}\n\nexport async function encryptFiledata(\n    worker,\n    filedata: Uint8Array | DataStream\n): Promise<EncryptionResult> {\n    return isDataStream(filedata)\n        ? await encryptFileStream(worker, filedata)\n        : await worker.encryptFile(filedata);\n}\n","import {\n    FILE_CHUNKS_COMBINED_FOR_A_UPLOAD_PART,\n    DataStream,\n} from './uploadService';\nimport UploadHttpClient from './uploadHttpClient';\nimport * as convert from 'xml-js';\nimport UIService, { RANDOM_PERCENTAGE_PROGRESS_FOR_PUT } from './uiService';\nimport { CustomError } from 'utils/common/errorUtil';\n\ninterface PartEtag {\n    PartNumber: number;\n    ETag: string;\n}\n\nexport interface MultipartUploadURLs {\n    objectKey: string;\n    partURLs: string[];\n    completeURL: string;\n}\n\nfunction calculatePartCount(chunkCount: number) {\n    const partCount = Math.ceil(\n        chunkCount / FILE_CHUNKS_COMBINED_FOR_A_UPLOAD_PART\n    );\n    return partCount;\n}\nexport async function uploadStreamUsingMultipart(\n    filename: string,\n    dataStream: DataStream\n) {\n    const uploadPartCount = calculatePartCount(dataStream.chunkCount);\n    const multipartUploadURLs = await UploadHttpClient.fetchMultipartUploadURLs(\n        uploadPartCount\n    );\n    const fileObjectKey = await uploadStreamInParts(\n        multipartUploadURLs,\n        dataStream.stream,\n        filename,\n        uploadPartCount\n    );\n    return fileObjectKey;\n}\n\nexport async function uploadStreamInParts(\n    multipartUploadURLs: MultipartUploadURLs,\n    dataStream: ReadableStream<Uint8Array>,\n    filename: string,\n    uploadPartCount: number\n) {\n    const streamReader = dataStream.getReader();\n    const percentPerPart = getRandomProgressPerPartUpload(uploadPartCount);\n\n    const partEtags: PartEtag[] = [];\n    for (const [\n        index,\n        fileUploadURL,\n    ] of multipartUploadURLs.partURLs.entries()) {\n        const uploadChunk = await combineChunksToFormUploadPart(streamReader);\n        const progressTracker = UIService.trackUploadProgress(\n            filename,\n            percentPerPart,\n            index\n        );\n\n        const eTag = await UploadHttpClient.putFilePart(\n            fileUploadURL,\n            uploadChunk,\n            progressTracker\n        );\n        partEtags.push({ PartNumber: index + 1, ETag: eTag });\n    }\n    const { done } = await streamReader.read();\n    if (!done) {\n        throw Error(CustomError.CHUNK_MORE_THAN_EXPECTED);\n    }\n    await completeMultipartUpload(partEtags, multipartUploadURLs.completeURL);\n    return multipartUploadURLs.objectKey;\n}\n\nfunction getRandomProgressPerPartUpload(uploadPartCount: number) {\n    const percentPerPart =\n        RANDOM_PERCENTAGE_PROGRESS_FOR_PUT() / uploadPartCount;\n    return percentPerPart;\n}\n\nasync function combineChunksToFormUploadPart(\n    streamReader: ReadableStreamDefaultReader<Uint8Array>\n) {\n    const combinedChunks = [];\n    for (let i = 0; i < FILE_CHUNKS_COMBINED_FOR_A_UPLOAD_PART; i++) {\n        const { done, value: chunk } = await streamReader.read();\n        if (done) {\n            break;\n        }\n        for (let index = 0; index < chunk.length; index++) {\n            combinedChunks.push(chunk[index]);\n        }\n    }\n    return Uint8Array.from(combinedChunks);\n}\n\nasync function completeMultipartUpload(\n    partEtags: PartEtag[],\n    completeURL: string\n) {\n    const options = { compact: true, ignoreComment: true, spaces: 4 };\n    const body = convert.js2xml(\n        { CompleteMultipartUpload: { Part: partEtags } },\n        options\n    );\n    await UploadHttpClient.completeMultipartUpload(completeURL, body);\n}\n","import { fileAttribute, FILE_TYPE } from '../fileService';\nimport { Collection } from '../collectionService';\nimport { logError } from 'utils/sentry';\nimport UploadHttpClient from './uploadHttpClient';\nimport {\n    extractMetadata,\n    getMetadataMapKey,\n    ParsedMetaDataJSON,\n} from './metadataService';\nimport { generateThumbnail } from './thumbnailService';\nimport {\n    getFileOriginalName,\n    getFileData,\n    FileTypeInfo,\n} from './readFileService';\nimport { encryptFiledata } from './encryptionService';\nimport { ENCRYPTION_CHUNK_SIZE } from 'types';\nimport { uploadStreamUsingMultipart } from './multiPartUploadService';\nimport UIService from './uiService';\nimport { handleUploadError } from 'utils/common/errorUtil';\nimport { MetadataMap } from './uploadManager';\n\n// this is the chunk size of the un-encrypted file which is read and encrypted before uploading it as a single part.\nexport const MULTIPART_PART_SIZE = 20 * 1024 * 1024;\n\nexport const FILE_READER_CHUNK_SIZE = ENCRYPTION_CHUNK_SIZE;\n\nexport const FILE_CHUNKS_COMBINED_FOR_A_UPLOAD_PART = Math.floor(\n    MULTIPART_PART_SIZE / FILE_READER_CHUNK_SIZE\n);\n\nexport interface UploadURL {\n    url: string;\n    objectKey: string;\n}\n\nexport interface DataStream {\n    stream: ReadableStream<Uint8Array>;\n    chunkCount: number;\n}\n\nexport function isDataStream(object: any): object is DataStream {\n    return 'stream' in object;\n}\nexport interface EncryptionResult {\n    file: fileAttribute;\n    key: string;\n}\nexport interface B64EncryptionResult {\n    encryptedData: string;\n    key: string;\n    nonce: string;\n}\n\nexport interface MetadataObject {\n    title: string;\n    creationTime: number;\n    modificationTime: number;\n    latitude: number;\n    longitude: number;\n    fileType: FILE_TYPE;\n    hasStaticThumbnail?: boolean;\n}\n\nexport interface FileInMemory {\n    filedata: Uint8Array | DataStream;\n    thumbnail: Uint8Array;\n    hasStaticThumbnail: boolean;\n}\n\nexport interface FileWithMetadata\n    extends Omit<FileInMemory, 'hasStaticThumbnail'> {\n    metadata: MetadataObject;\n}\n\nexport interface EncryptedFile {\n    file: ProcessedFile;\n    fileKey: B64EncryptionResult;\n}\nexport interface ProcessedFile {\n    file: fileAttribute;\n    thumbnail: fileAttribute;\n    metadata: fileAttribute;\n    filename: string;\n}\nexport interface BackupedFile extends Omit<ProcessedFile, 'filename'> {}\n\nexport interface UploadFile extends BackupedFile {\n    collectionID: number;\n    encryptedKey: string;\n    keyDecryptionNonce: string;\n}\n\nclass UploadService {\n    private uploadURLs: UploadURL[] = [];\n    private metadataMap: Map<string, ParsedMetaDataJSON>;\n    private pendingUploadCount: number = 0;\n\n    async init(fileCount: number, metadataMap: MetadataMap) {\n        this.pendingUploadCount = fileCount;\n        this.metadataMap = metadataMap;\n        await this.preFetchUploadURLs();\n    }\n\n    async readFile(\n        worker: any,\n        rawFile: globalThis.File,\n        fileTypeInfo: FileTypeInfo\n    ): Promise<FileInMemory> {\n        const { thumbnail, hasStaticThumbnail } = await generateThumbnail(\n            worker,\n            rawFile,\n            fileTypeInfo\n        );\n\n        const filedata = await getFileData(worker, rawFile);\n\n        return {\n            filedata,\n            thumbnail,\n            hasStaticThumbnail,\n        };\n    }\n\n    async getFileMetadata(\n        rawFile: File,\n        collection: Collection,\n        fileTypeInfo: FileTypeInfo\n    ): Promise<MetadataObject> {\n        const originalName = getFileOriginalName(rawFile);\n        const googleMetadata =\n            this.metadataMap.get(\n                getMetadataMapKey(collection.id, originalName)\n            ) ?? {};\n        const extractedMetadata: MetadataObject = await extractMetadata(\n            rawFile,\n            fileTypeInfo\n        );\n\n        for (const [key, value] of Object.entries(googleMetadata)) {\n            if (!value) {\n                continue;\n            }\n            extractedMetadata[key] = value;\n        }\n        return extractedMetadata;\n    }\n\n    async encryptFile(\n        worker: any,\n        file: FileWithMetadata,\n        encryptionKey: string\n    ): Promise<EncryptedFile> {\n        try {\n            const { key: fileKey, file: encryptedFiledata } =\n                await encryptFiledata(worker, file.filedata);\n\n            const { file: encryptedThumbnail }: EncryptionResult =\n                await worker.encryptThumbnail(file.thumbnail, fileKey);\n            const { file: encryptedMetadata }: EncryptionResult =\n                await worker.encryptMetadata(file.metadata, fileKey);\n\n            const encryptedKey: B64EncryptionResult = await worker.encryptToB64(\n                fileKey,\n                encryptionKey\n            );\n\n            const result: EncryptedFile = {\n                file: {\n                    file: encryptedFiledata,\n                    thumbnail: encryptedThumbnail,\n                    metadata: encryptedMetadata,\n                    filename: file.metadata.title,\n                },\n                fileKey: encryptedKey,\n            };\n            return result;\n        } catch (e) {\n            logError(e, 'Error encrypting files');\n            throw e;\n        }\n    }\n\n    async uploadToBucket(file: ProcessedFile): Promise<BackupedFile> {\n        try {\n            let fileObjectKey: string = null;\n            if (isDataStream(file.file.encryptedData)) {\n                fileObjectKey = await uploadStreamUsingMultipart(\n                    file.filename,\n                    file.file.encryptedData\n                );\n            } else {\n                const progressTracker = UIService.trackUploadProgress(\n                    file.filename\n                );\n                const fileUploadURL = await this.getUploadURL();\n                fileObjectKey = await UploadHttpClient.putFile(\n                    fileUploadURL,\n                    file.file.encryptedData,\n                    progressTracker\n                );\n            }\n            const thumbnailUploadURL = await this.getUploadURL();\n            const thumbnailObjectKey = await UploadHttpClient.putFile(\n                thumbnailUploadURL,\n                file.thumbnail.encryptedData as Uint8Array,\n                null\n            );\n\n            const backupedFile: BackupedFile = {\n                file: {\n                    decryptionHeader: file.file.decryptionHeader,\n                    objectKey: fileObjectKey,\n                },\n                thumbnail: {\n                    decryptionHeader: file.thumbnail.decryptionHeader,\n                    objectKey: thumbnailObjectKey,\n                },\n                metadata: file.metadata,\n            };\n            return backupedFile;\n        } catch (e) {\n            logError(e, 'error uploading to bucket');\n            throw e;\n        }\n    }\n\n    getUploadFile(\n        collection: Collection,\n        backupedFile: BackupedFile,\n        fileKey: B64EncryptionResult\n    ): UploadFile {\n        const uploadFile: UploadFile = {\n            collectionID: collection.id,\n            encryptedKey: fileKey.encryptedData,\n            keyDecryptionNonce: fileKey.nonce,\n            ...backupedFile,\n        };\n        uploadFile;\n        return uploadFile;\n    }\n\n    private async getUploadURL() {\n        if (this.uploadURLs.length === 0 && this.pendingUploadCount) {\n            await this.fetchUploadURLs();\n        }\n        return this.uploadURLs.pop();\n    }\n\n    public async preFetchUploadURLs() {\n        try {\n            await this.fetchUploadURLs();\n            // checking for any subscription related errors\n        } catch (e) {\n            logError(e, 'prefetch uploadURL failed');\n            handleUploadError(e);\n        }\n    }\n\n    private async fetchUploadURLs() {\n        await UploadHttpClient.fetchUploadURLs(\n            this.pendingUploadCount,\n            this.uploadURLs\n        );\n    }\n}\n\nexport default new UploadService();\n","import constants from 'utils/strings/constants';\nimport billingService, {\n    FREE_PLAN,\n    Plan,\n    Subscription,\n} from 'services/billingService';\nimport { NextRouter } from 'next/router';\nimport { SetDialogMessage } from 'components/MessageDialog';\nimport { SetLoading } from 'pages/gallery';\nimport { getData, LS_KEYS } from './storage/localStorage';\nimport { CustomError } from './common/errorUtil';\nimport { logError } from './sentry';\n\nconst STRIPE = 'stripe';\n\nenum FAILURE_REASON {\n    AUTHENTICATION_FAILED = 'authentication_failed',\n    REQUIRE_PAYMENT_METHOD = 'requires_payment_method',\n    STRIPE_ERROR = 'stripe_error',\n    CANCELED = 'canceled',\n    SERVER_ERROR = 'server_error',\n}\n\nenum RESPONSE_STATUS {\n    success = 'success',\n    fail = 'fail',\n}\n\nexport function convertBytesToGBs(bytes, precision?): string {\n    return (bytes / (1024 * 1024 * 1024)).toFixed(precision ?? 2);\n}\n\nexport function convertToHumanReadable(bytes: number, precision = 2): string {\n    if (bytes === 0) {\n        return '0 MB';\n    }\n    const i = Math.floor(Math.log(bytes) / Math.log(1024));\n    const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n    return (bytes / Math.pow(1024, i)).toFixed(precision) + ' ' + sizes[i];\n}\n\nexport function hasPaidSubscription(subscription?: Subscription) {\n    subscription = subscription ?? getUserSubscription();\n    return (\n        subscription &&\n        isSubscriptionActive(subscription) &&\n        subscription.productID !== FREE_PLAN\n    );\n}\n\nexport function isSubscribed(subscription?: Subscription) {\n    subscription = subscription ?? getUserSubscription();\n    return (\n        hasPaidSubscription(subscription) &&\n        !isSubscriptionCancelled(subscription)\n    );\n}\nexport function isSubscriptionActive(subscription?: Subscription): boolean {\n    subscription = subscription ?? getUserSubscription();\n    return subscription && subscription.expiryTime > Date.now() * 1000;\n}\n\nexport function isOnFreePlan(subscription?: Subscription) {\n    subscription = subscription ?? getUserSubscription();\n    return (\n        subscription &&\n        isSubscriptionActive(subscription) &&\n        subscription.productID === FREE_PLAN\n    );\n}\n\nexport function isSubscriptionCancelled(subscription?: Subscription) {\n    subscription = subscription ?? getUserSubscription();\n    return subscription && subscription.attributes.isCancelled;\n}\n\nexport function getUserSubscription(): Subscription {\n    return getData(LS_KEYS.SUBSCRIPTION);\n}\n\nexport function getPlans(): Plan[] {\n    return getData(LS_KEYS.PLANS);\n}\nexport function isUserSubscribedPlan(plan: Plan, subscription: Subscription) {\n    return (\n        isSubscriptionActive(subscription) &&\n        (plan.stripeID === subscription.productID ||\n            plan.iosID === subscription.productID ||\n            plan.androidID === subscription.productID)\n    );\n}\nexport function hasStripeSubscription(subscription: Subscription) {\n    return (\n        hasPaidSubscription(subscription) &&\n        subscription.paymentProvider.length > 0 &&\n        subscription.paymentProvider === STRIPE\n    );\n}\n\nexport async function updateSubscription(\n    plan: Plan,\n    setDialogMessage: SetDialogMessage,\n    setLoading: SetLoading,\n    closePlanSelectorModal: () => null\n) {\n    try {\n        setLoading(true);\n        await billingService.updateSubscription(plan.stripeID);\n    } catch (err) {\n        setDialogMessage({\n            title: constants.ERROR,\n            content: constants.SUBSCRIPTION_UPDATE_FAILED,\n            close: { variant: 'danger' },\n        });\n    } finally {\n        setLoading(false);\n        closePlanSelectorModal();\n    }\n}\n\nexport async function cancelSubscription(\n    setDialogMessage: SetDialogMessage,\n    closePlanSelectorModal: () => null,\n    setLoading: SetLoading\n) {\n    try {\n        setLoading(true);\n        await billingService.cancelSubscription();\n        setDialogMessage({\n            title: constants.SUCCESS,\n            content: constants.SUBSCRIPTION_CANCEL_SUCCESS,\n            close: { variant: 'success' },\n        });\n    } catch (e) {\n        setDialogMessage({\n            title: constants.ERROR,\n            content: constants.SUBSCRIPTION_CANCEL_FAILED,\n            close: { variant: 'danger' },\n        });\n    } finally {\n        closePlanSelectorModal();\n        setLoading(false);\n    }\n}\n\nexport async function activateSubscription(\n    setDialogMessage: SetDialogMessage,\n    closePlanSelectorModal: () => null,\n    setLoading: SetLoading\n) {\n    try {\n        setLoading(true);\n        await billingService.activateSubscription();\n        setDialogMessage({\n            title: constants.SUCCESS,\n            content: constants.SUBSCRIPTION_ACTIVATE_SUCCESS,\n            close: { variant: 'success' },\n        });\n    } catch (e) {\n        setDialogMessage({\n            title: constants.ERROR,\n            content: constants.SUBSCRIPTION_ACTIVATE_FAILED,\n            close: { variant: 'danger' },\n        });\n    } finally {\n        closePlanSelectorModal();\n        setLoading(false);\n    }\n}\n\nexport async function updatePaymentMethod(\n    setDialogMessage: SetDialogMessage,\n    setLoading: SetLoading\n) {\n    try {\n        setLoading(true);\n        await billingService.redirectToCustomerPortal();\n    } catch (error) {\n        setLoading(false);\n        setDialogMessage({\n            title: constants.ERROR,\n            content: constants.UNKNOWN_ERROR,\n            close: { variant: 'danger' },\n        });\n    }\n}\n\nexport async function checkSubscriptionPurchase(\n    setDialogMessage: SetDialogMessage,\n    router: NextRouter,\n    setLoading: SetLoading\n) {\n    const { session_id: sessionId, status, reason } = router.query ?? {};\n    try {\n        if (status === RESPONSE_STATUS.fail) {\n            handleFailureReason(reason as string, setDialogMessage, setLoading);\n        } else if (status === RESPONSE_STATUS.success) {\n            try {\n                const subscription = await billingService.verifySubscription(\n                    sessionId as string\n                );\n                setDialogMessage({\n                    title: constants.SUBSCRIPTION_PURCHASE_SUCCESS_TITLE,\n                    close: { variant: 'success' },\n                    content: constants.SUBSCRIPTION_PURCHASE_SUCCESS(\n                        subscription?.expiryTime\n                    ),\n                });\n            } catch (e) {\n                setDialogMessage({\n                    title: constants.ERROR,\n                    content: CustomError.SUBSCRIPTION_VERIFICATION_ERROR,\n                    close: {},\n                });\n            }\n        }\n    } catch (e) {\n        // ignore\n    }\n}\n\nfunction handleFailureReason(\n    reason: string,\n    setDialogMessage: SetDialogMessage,\n    setLoading: SetLoading\n): void {\n    logError(Error(reason), 'subscription purchase failed');\n    switch (reason) {\n        case FAILURE_REASON.CANCELED:\n            setDialogMessage({\n                title: constants.MESSAGE,\n                content: constants.SUBSCRIPTION_PURCHASE_CANCELLED,\n                close: { variant: 'danger' },\n            });\n            break;\n        case FAILURE_REASON.REQUIRE_PAYMENT_METHOD:\n            setDialogMessage({\n                title: constants.UPDATE_PAYMENT_METHOD,\n                content: constants.UPDATE_PAYMENT_METHOD_MESSAGE,\n                staticBackdrop: true,\n                proceed: {\n                    text: constants.UPDATE_PAYMENT_METHOD,\n                    variant: 'success',\n                    action: updatePaymentMethod.bind(\n                        null,\n\n                        setDialogMessage,\n                        setLoading\n                    ),\n                },\n                close: { text: constants.CANCEL },\n            });\n            break;\n\n        case FAILURE_REASON.AUTHENTICATION_FAILED:\n            setDialogMessage({\n                title: constants.UPDATE_PAYMENT_METHOD,\n                content: constants.STRIPE_AUTHENTICATION_FAILED,\n                staticBackdrop: true,\n                proceed: {\n                    text: constants.UPDATE_PAYMENT_METHOD,\n                    variant: 'success',\n                    action: updatePaymentMethod.bind(\n                        null,\n\n                        setDialogMessage,\n                        setLoading\n                    ),\n                },\n                close: { text: constants.CANCEL },\n            });\n            break;\n\n        default:\n            setDialogMessage({\n                title: constants.ERROR,\n                content: constants.SUBSCRIPTION_PURCHASE_FAILED,\n                close: { variant: 'danger' },\n            });\n    }\n}\n\nexport function planForSubscription(subscription: Subscription) {\n    if (!subscription) {\n        return null;\n    }\n    return {\n        id: subscription.productID,\n        storage: subscription.storage,\n        price: subscription.price,\n        period: subscription.period,\n        stripeID: subscription.productID,\n        iosID: subscription.productID,\n        androidID: subscription.productID,\n    };\n}\n","import { SelectedState } from 'pages/gallery';\nimport { Collection } from 'services/collectionService';\nimport {\n    File,\n    fileAttribute,\n    FILE_TYPE,\n    MagicMetadataProps,\n    NEW_MAGIC_METADATA,\n    PublicMagicMetadataProps,\n    VISIBILITY_STATE,\n} from 'services/fileService';\nimport { decodeMotionPhoto } from 'services/motionPhotoService';\nimport { getMimeTypeFromBlob } from 'services/upload/readFileService';\nimport DownloadManager from 'services/downloadManager';\nimport { logError } from 'utils/sentry';\nimport { User } from 'services/userService';\nimport CryptoWorker from 'utils/crypto';\nimport { getData, LS_KEYS } from 'utils/storage/localStorage';\n\nexport const TYPE_HEIC = 'heic';\nexport const TYPE_HEIF = 'heif';\nconst UNSUPPORTED_FORMATS = ['flv', 'mkv', '3gp', 'avi', 'wmv'];\n\nexport function downloadAsFile(filename: string, content: string) {\n    const file = new Blob([content], {\n        type: 'text/plain',\n    });\n    const a = document.createElement('a');\n    a.href = URL.createObjectURL(file);\n    a.download = filename;\n\n    a.style.display = 'none';\n    document.body.appendChild(a);\n\n    a.click();\n\n    a.remove();\n}\n\nexport async function downloadFile(file: File) {\n    const a = document.createElement('a');\n    a.style.display = 'none';\n    const cachedFileUrl = await DownloadManager.getCachedOriginalFile(file);\n    const fileURL =\n        cachedFileUrl ??\n        URL.createObjectURL(\n            await new Response(await DownloadManager.downloadFile(file)).blob()\n        );\n    a.href = fileURL;\n    if (file.metadata.fileType === FILE_TYPE.LIVE_PHOTO) {\n        a.download = fileNameWithoutExtension(file.metadata.title) + '.zip';\n    } else {\n        a.download = file.metadata.title;\n    }\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n}\n\nexport function isFileHEIC(mimeType: string) {\n    return (\n        mimeType &&\n        (mimeType.toLowerCase().endsWith(TYPE_HEIC) ||\n            mimeType.toLowerCase().endsWith(TYPE_HEIF))\n    );\n}\n\nexport function sortFilesIntoCollections(files: File[]) {\n    const collectionWiseFiles = new Map<number, File[]>();\n    for (const file of files) {\n        if (!collectionWiseFiles.has(file.collectionID)) {\n            collectionWiseFiles.set(file.collectionID, []);\n        }\n        collectionWiseFiles.get(file.collectionID).push(file);\n    }\n    return collectionWiseFiles;\n}\n\nfunction getSelectedFileIds(selectedFiles: SelectedState) {\n    const filesIDs: number[] = [];\n    for (const [key, val] of Object.entries(selectedFiles)) {\n        if (typeof val === 'boolean' && val) {\n            filesIDs.push(Number(key));\n        }\n    }\n    return filesIDs;\n}\nexport function getSelectedFiles(\n    selected: SelectedState,\n    files: File[]\n): File[] {\n    const filesIDs = new Set(getSelectedFileIds(selected));\n    const selectedFiles: File[] = [];\n    const foundFiles = new Set<number>();\n    for (const file of files) {\n        if (filesIDs.has(file.id) && !foundFiles.has(file.id)) {\n            selectedFiles.push(file);\n            foundFiles.add(file.id);\n        }\n    }\n    return selectedFiles;\n}\n\nexport function checkFileFormatSupport(name: string) {\n    for (const format of UNSUPPORTED_FORMATS) {\n        if (name.toLowerCase().endsWith(format)) {\n            throw Error('unsupported format');\n        }\n    }\n}\n\nexport function formatDate(date: number | Date) {\n    const dateTimeFormat = new Intl.DateTimeFormat('en-IN', {\n        weekday: 'short',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n    });\n    return dateTimeFormat.format(date);\n}\n\nexport function formatDateTime(date: number | Date) {\n    const dateTimeFormat = new Intl.DateTimeFormat('en-IN', {\n        weekday: 'short',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n    });\n    const timeFormat = new Intl.DateTimeFormat('en-IN', {\n        timeStyle: 'medium',\n    });\n    return `${dateTimeFormat.format(date)} ${timeFormat.format(date)}`;\n}\n\nexport function formatDateRelative(date: number) {\n    const units = {\n        year: 24 * 60 * 60 * 1000 * 365,\n        month: (24 * 60 * 60 * 1000 * 365) / 12,\n        day: 24 * 60 * 60 * 1000,\n        hour: 60 * 60 * 1000,\n        minute: 60 * 1000,\n        second: 1000,\n    };\n    const relativeDateFormat = new Intl.RelativeTimeFormat('en-IN', {\n        localeMatcher: 'best fit',\n        numeric: 'always',\n        style: 'long',\n    });\n    const elapsed = date - Date.now();\n\n    // \"Math.abs\" accounts for both \"past\" & \"future\" scenarios\n    for (const u in units)\n        if (Math.abs(elapsed) > units[u] || u === 'second')\n            return relativeDateFormat.format(\n                Math.round(elapsed / units[u]),\n                u as Intl.RelativeTimeFormatUnit\n            );\n}\n\nexport function sortFiles(files: File[]) {\n    // sort according to modification time first\n    files = files.sort((a, b) => {\n        if (!b.metadata?.modificationTime) {\n            return -1;\n        }\n        if (!a.metadata?.modificationTime) {\n            return 1;\n        } else {\n            return b.metadata.modificationTime - a.metadata.modificationTime;\n        }\n    });\n\n    // then sort according to creation time, maintaining ordering according to modification time for files with creation time\n    files = files\n        .map((file, index) => ({ index, file }))\n        .sort((a, b) => {\n            let diff =\n                b.file.metadata.creationTime - a.file.metadata.creationTime;\n            if (diff === 0) {\n                diff = a.index - b.index;\n            }\n            return diff;\n        })\n        .map((file) => file.file);\n    return files;\n}\n\nexport async function decryptFile(file: File, collection: Collection) {\n    try {\n        const worker = await new CryptoWorker();\n        file.key = await worker.decryptB64(\n            file.encryptedKey,\n            file.keyDecryptionNonce,\n            collection.key\n        );\n        const encryptedMetadata = file.metadata as unknown as fileAttribute;\n        file.metadata = await worker.decryptMetadata(\n            encryptedMetadata.encryptedData,\n            encryptedMetadata.decryptionHeader,\n            file.key\n        );\n        if (file.magicMetadata?.data) {\n            file.magicMetadata.data = await worker.decryptMetadata(\n                file.magicMetadata.data,\n                file.magicMetadata.header,\n                file.key\n            );\n        }\n        if (file.pubMagicMetadata?.data) {\n            file.pubMagicMetadata.data = await worker.decryptMetadata(\n                file.pubMagicMetadata.data,\n                file.pubMagicMetadata.header,\n                file.key\n            );\n        }\n        return file;\n    } catch (e) {\n        logError(e, 'file decryption failed');\n        throw e;\n    }\n}\n\nexport function removeUnnecessaryFileProps(files: File[]): File[] {\n    const stripedFiles = files.map((file) => {\n        delete file.src;\n        delete file.msrc;\n        delete file.file.objectKey;\n        delete file.thumbnail.objectKey;\n        delete file.h;\n        delete file.html;\n        delete file.w;\n\n        return file;\n    });\n    return stripedFiles;\n}\n\nexport function fileNameWithoutExtension(filename) {\n    const lastDotPosition = filename.lastIndexOf('.');\n    if (lastDotPosition === -1) return filename;\n    else return filename.substr(0, lastDotPosition);\n}\n\nexport function fileExtensionWithDot(filename) {\n    const lastDotPosition = filename.lastIndexOf('.');\n    if (lastDotPosition === -1) return '';\n    else return filename.substr(lastDotPosition);\n}\n\nexport function splitFilenameAndExtension(filename): [string, string] {\n    const lastDotPosition = filename.lastIndexOf('.');\n    if (lastDotPosition === -1) return [filename, null];\n    else\n        return [\n            filename.substr(0, lastDotPosition),\n            filename.substr(lastDotPosition + 1),\n        ];\n}\n\nexport function generateStreamFromArrayBuffer(data: Uint8Array) {\n    return new ReadableStream({\n        async start(controller: ReadableStreamDefaultController) {\n            controller.enqueue(data);\n            controller.close();\n        },\n    });\n}\n\nexport async function convertForPreview(file: File, fileBlob: Blob) {\n    if (file.metadata.fileType === FILE_TYPE.LIVE_PHOTO) {\n        const originalName = fileNameWithoutExtension(file.metadata.title);\n        const motionPhoto = await decodeMotionPhoto(fileBlob, originalName);\n        fileBlob = new Blob([motionPhoto.image]);\n    }\n\n    const typeFromExtension = file.metadata.title.split('.')[-1];\n    const worker = await new CryptoWorker();\n\n    const mimeType =\n        (await getMimeTypeFromBlob(worker, fileBlob)) ?? typeFromExtension;\n    if (isFileHEIC(mimeType)) {\n        fileBlob = await worker.convertHEIC2JPEG(fileBlob);\n    }\n    return fileBlob;\n}\n\nexport function fileIsArchived(file: File) {\n    if (\n        !file ||\n        !file.magicMetadata ||\n        !file.magicMetadata.data ||\n        typeof file.magicMetadata.data === 'string' ||\n        typeof file.magicMetadata.data.visibility === 'undefined'\n    ) {\n        return false;\n    }\n    return file.magicMetadata.data.visibility === VISIBILITY_STATE.ARCHIVED;\n}\n\nexport async function updateMagicMetadataProps(\n    file: File,\n    magicMetadataUpdates: MagicMetadataProps\n) {\n    const worker = await new CryptoWorker();\n\n    if (!file.magicMetadata) {\n        file.magicMetadata = NEW_MAGIC_METADATA;\n    }\n    if (typeof file.magicMetadata.data === 'string') {\n        file.magicMetadata.data = (await worker.decryptMetadata(\n            file.magicMetadata.data,\n            file.magicMetadata.header,\n            file.key\n        )) as MagicMetadataProps;\n    }\n    if (magicMetadataUpdates) {\n        // copies the existing magic metadata properties of the files and updates the visibility value\n        // The expected behaviour while updating magic metadata is to let the existing property as it is and update/add the property you want\n        const magicMetadataProps: MagicMetadataProps = {\n            ...file.magicMetadata.data,\n            ...magicMetadataUpdates,\n        };\n\n        return {\n            ...file,\n            magicMetadata: {\n                ...file.magicMetadata,\n                data: magicMetadataProps,\n                count: Object.keys(file.magicMetadata.data).length,\n            },\n        };\n    } else {\n        return file;\n    }\n}\nexport async function updatePublicMagicMetadataProps(\n    file: File,\n    publicMetadataUpdates: PublicMagicMetadataProps\n) {\n    const worker = await new CryptoWorker();\n\n    if (!file.pubMagicMetadata) {\n        file.pubMagicMetadata = NEW_MAGIC_METADATA;\n    }\n    if (typeof file.pubMagicMetadata.data === 'string') {\n        file.pubMagicMetadata.data = (await worker.decryptMetadata(\n            file.pubMagicMetadata.data,\n            file.pubMagicMetadata.header,\n            file.key\n        )) as PublicMagicMetadataProps;\n    }\n\n    if (publicMetadataUpdates) {\n        const publicMetadataProps = {\n            ...file.pubMagicMetadata.data,\n            ...publicMetadataUpdates,\n        };\n        return {\n            ...file,\n            pubMagicMetadata: {\n                ...file.pubMagicMetadata,\n                data: publicMetadataProps,\n                count: Object.keys(file.pubMagicMetadata.data).length,\n            },\n        };\n    } else {\n        return file;\n    }\n}\n\nexport async function changeFilesVisibility(\n    files: File[],\n    selected: SelectedState,\n    visibility: VISIBILITY_STATE\n) {\n    const selectedFiles = getSelectedFiles(selected, files);\n    const updatedFiles: File[] = [];\n    for (const file of selectedFiles) {\n        const updatedMagicMetadataProps: MagicMetadataProps = {\n            visibility,\n        };\n\n        updatedFiles.push(\n            await updateMagicMetadataProps(file, updatedMagicMetadataProps)\n        );\n    }\n    return updatedFiles;\n}\n\nexport async function changeFileCreationTime(file: File, editedTime: number) {\n    const updatedPublicMagicMetadataProps: PublicMagicMetadataProps = {\n        editedTime,\n    };\n\n    return await updatePublicMagicMetadataProps(\n        file,\n        updatedPublicMagicMetadataProps\n    );\n}\n\nexport async function changeFileName(file: File, editedName: string) {\n    const updatedPublicMagicMetadataProps: PublicMagicMetadataProps = {\n        editedName,\n    };\n\n    return await updatePublicMagicMetadataProps(\n        file,\n        updatedPublicMagicMetadataProps\n    );\n}\n\nexport function isSharedFile(file: File) {\n    const user: User = getData(LS_KEYS.USER);\n\n    if (!user?.id || !file?.ownerID) {\n        return false;\n    }\n    return file.ownerID !== user.id;\n}\n\nexport function mergeMetadata(files: File[]): File[] {\n    return files.map((file) => ({\n        ...file,\n        metadata: {\n            ...file.metadata,\n            ...(file.pubMagicMetadata?.data\n                ? {\n                      ...(file.pubMagicMetadata?.data.editedTime && {\n                          creationTime: file.pubMagicMetadata.data.editedTime,\n                      }),\n                      ...(file.pubMagicMetadata?.data.editedName && {\n                          title: file.pubMagicMetadata.data.editedName,\n                      }),\n                  }\n                : {}),\n            ...(file.magicMetadata?.data ? file.magicMetadata.data : {}),\n        },\n    }));\n}\n\nexport function updateExistingFilePubMetadata(\n    existingFile: File,\n    updatedFile: File\n) {\n    existingFile.pubMagicMetadata = updatedFile.pubMagicMetadata;\n    existingFile.metadata = mergeMetadata([existingFile])[0].metadata;\n}\n\nexport async function getFileFromURL(fileURL: string) {\n    const fileBlob = await (await fetch(fileURL)).blob();\n    const fileFile = new globalThis.File([fileBlob], 'temp');\n    return fileFile;\n}\n\nexport function getUniqueFiles(files: File[]) {\n    const idSet = new Set<number>();\n    return files.filter((file) => {\n        if (!idSet.has(file.id)) {\n            idSet.add(file.id);\n            return true;\n        } else {\n            return false;\n        }\n    });\n}\nexport function getNonTrashedUniqueUserFiles(files: File[]) {\n    const user: User = getData(LS_KEYS.USER) ?? {};\n    return getUniqueFiles(\n        files.filter(\n            (file) =>\n                (typeof file.isTrashed === 'undefined' || !file.isTrashed) &&\n                (!user.id || file.ownerID === user.id)\n        )\n    );\n}\n\nexport async function downloadFiles(files: File[]) {\n    for (const file of files) {\n        try {\n            await downloadFile(file);\n        } catch (e) {\n            logError(e, 'download fail for file');\n        }\n    }\n}\n\nexport function needsConversionForPreview(file: File) {\n    const fileExtension = splitFilenameAndExtension(file.metadata.title)[1];\n    if (\n        file.metadata.fileType === FILE_TYPE.LIVE_PHOTO ||\n        (file.metadata.fileType === FILE_TYPE.IMAGE &&\n            isFileHEIC(fileExtension))\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n","import { sleep } from 'utils/common';\n\nconst retrySleepTimeInMilliSeconds = [2000, 5000, 10000];\n\nexport async function retryAsyncFunction(\n    func: () => Promise<any>,\n    checkForBreakingError?: (error) => void\n) {\n    const retrier = async (\n        func: () => Promise<any>,\n        attemptNumber: number = 0\n    ) => {\n        try {\n            const resp = await func();\n            return resp;\n        } catch (e) {\n            if (checkForBreakingError) {\n                checkForBreakingError(e);\n            }\n            if (attemptNumber < retrySleepTimeInMilliSeconds.length) {\n                await sleep(retrySleepTimeInMilliSeconds[attemptNumber]);\n                return await retrier(func, attemptNumber + 1);\n            } else {\n                throw e;\n            }\n        }\n    };\n    return await retrier(func);\n}\n","import { getData, LS_KEYS, setData } from './localStorage';\n\nexport const isFirstLogin = () =>\n    getData(LS_KEYS.IS_FIRST_LOGIN)?.status ?? false;\n\nexport function setIsFirstLogin(status) {\n    setData(LS_KEYS.IS_FIRST_LOGIN, { status });\n}\n\nexport const justSignedUp = () =>\n    getData(LS_KEYS.JUST_SIGNED_UP)?.status ?? false;\n\nexport function setJustSignedUp(status) {\n    setData(LS_KEYS.JUST_SIGNED_UP, { status });\n}\n"],"names":["MessageDialog","attributes","children","props","onHide","nonClosable","centered","backdrop","staticBackdrop","style","borderBottom","closeButton","title","content","borderTop","fontSize","marginBottom","close","proceed","display","flexWrap","variant","onClick","action","padding","margin","flex","whiteSpace","text","constants","disabled","bip39","require","setDefaultWordlist","CodeBlock","styled","height","FreeFlowText","somethingWentWrong","useState","recoveryKey","setRecoveryKey","onClose","useEffect","show","getRecoveryKey","entropyToMnemonic","main","size","downloadAsFile","PaymentActionType","ENDPOINT","getEndpoint","FREE_PLAN","billingService","HTTPService","response","plans","data","logError","getToken","subscription","setData","LS_KEYS","productID","getPaymentToken","paymentToken","this","redirectToPayments","Buy","Update","sessionID","token","paymentProvider","VerificationData","window","location","href","getPaymentsUrl","origin","redirectURL","url","startTime","endTime","Date","now","convertToHumanReadable","usage","DownloadManager","Map","file","getThumbnailUrl","id","responseType","resp","CryptoWorker","worker","Uint8Array","fromB64","thumbnail","decryptionHeader","key","decryptThumbnail","decrypted","forPreview","shouldBeConverted","needsConversionForPreview","fileKey","getFilePromise","convert","downloadFile","fileStream","Response","blob","fileBlob","convertForPreview","URL","createObjectURL","fileObjectUrlPromise","get","set","fileURL","thumbnailObjectUrlPromise","downloadPromise","caches","open","thumbnailCache","match","toString","cacheResp","downloadThumb","thumb","thumbBlob","Blob","put","metadata","fileType","FILE_TYPE","getFileUrl","decryptFile","generateStreamFromArrayBuffer","fetch","headers","reader","body","getReader","stream","ReadableStream","start","controller","push","read","then","done","value","buffer","byteLength","length","decryptionChunkSize","fileData","slice","decryptChunk","pullState","decryptedData","enqueue","initDecryption","FILES_TABLE","MIN_EDITED_CREATION_TIME","MAX_EDITED_CREATION_TIME","ALL_TIME","MAX_EDITED_FILE_NAME_LENGTH","VISIBILITY_STATE","FORMAT_MISSED_BY_FILE_TYPE_LIB","IMAGE","exactType","VIDEO","NEW_MAGIC_METADATA","version","header","count","getLocalFiles","localForage","files","setLocalFiles","getCollectionLastSyncTime","collection","syncFiles","collections","setFiles","localFiles","removeDeletedCollectionFiles","sortFiles","mergeMetadata","lastSyncTime","updationTime","getFiles","fetchedFiles","latestVersionFiles","forEach","uid","collectionID","has","isDeleted","sinceTime","decryptedFiles","time","Promise","all","diff","map","filter","item","hasMore","syncedCollectionIds","Set","add","trashFiles","filesToTrash","trashRequest","items","fileID","deleteFromTrash","filesToDelete","fileIDs","updateMagicMetadata","reqBody","metadataList","encryptMetadata","magicMetadata","encryptedMagicMetadata","encryptedData","updatePublicMagicMetadata","pubMagicMetadata","encryptedPubMagicMetadata","MotionPhoto","decodeMotionPhoto","zipBlob","originalName","JSZip","createFolders","zip","motionPhoto","zipFilename","startsWith","imageNameTitle","fileExtensionWithDot","async","image","videoNameTitle","video","EXIF_TAGS_NEEDED","getExifData","receivedFile","fileTypeInfo","nullExifData","NULL_LOCATION","creationTime","getRawExif","exifData","parsedEXIFData","getEXIFLocation","getUNIXTime","DateTimeOriginal","CreateDate","ModifyDate","exifr","dateTime","unixTime","getTime","e","latitude","longitude","NULL_PARSED_METADATA_JSON","modificationTime","extractMetadata","extractedMetadata","name","lastModified","getMetadataMapKey","parseMetadataJSON","resolve","reject","FileReader","onabort","Error","onerror","onload","result","TextDecoder","decode","JSON","parse","readAsText","metadataJSON","parsedMetaDataJSON","locationData","TYPE_VIDEO","TYPE_IMAGE","EDITED_FILE_SUFFIX","getFileData","MULTIPART_PART_SIZE","getFileStream","FILE_READER_CHUNK_SIZE","getUint8ArrayView","getFileType","getMimeType","mimeType","typeParts","split","CustomError","fileFormat","pop","formatMissedByTypeDetection","a","getFileOriginalName","endsWith","fileChunkBlob","getMimeTypeFromBlob","initialFiledata","FileType","mime","chunkSize","fileChunkReader","fileChunkReaderMaker","pull","next","chunk","chunkCount","Math","ceil","offset","fileChunk","TextEncoder","encode","readAsArrayBuffer","BLACK_THUMBNAIL_BASE64","QueueProcessor","maxParallelProcesses","request","isCanceled","status","canceller","exec","promise","requestQueue","successCallback","failureCallback","pollQueue","requestInProcessing","processQueue","queueItem","generateThumbnailHelper","ffmpeg","inputFileName","thumbFileName","FS","seekTime","run","toFixed","Number","FFmpegService","createFFmpeg","corePath","isLoading","load","init","generateThumbnailProcessor","queueUpRequest","bind","message","MAX_THUMBNAIL_DIMENSION","MAX_THUMBNAIL_SIZE","WAIT_TIME_THUMBNAIL_GENERATION","generateThumbnail","hasStaticThumbnail","canvas","document","createElement","isHEIC","isFileHEIC","generateImageThumbnail","dummyImageFile","File","generateVideoThumbnail","thumbnailCanvasToBlob","thumbnailBlob","from","atob","c","charCodeAt","canvasCTX","getContext","imageURL","timeout","globalThis","convertHEIC2JPEG","Image","setAttribute","thumbnailDimension","calculateThumbnailDimension","width","drawImage","clearTimeout","err","errorWithContext","setTimeout","videoURL","addEventListener","videoWidth","videoHeight","preload","src","prevSize","MAX_SAFE_INTEGER","quality","toBlob","percentageSizeDiff","thumbnailSize","newThumbnailSize","oldThumbnailSize","originalDimension","maxDimension","widthScaleFactor","heightScaleFactor","scaleFactor","min","round","RANDOM_PERCENTAGE_PROGRESS_FOR_PUT","random","UIService","progressUpdater","setTotalFileCount","filesUploaded","fileProgress","uploadResult","updateProgressBarUI","totalFileCount","perFileProgress","filename","progress","stage","setUploadStage","percent","setPercentComplete","setFileCounter","setFileProgress","setUploadResult","finished","total","percentComplete","percentPerPart","index","cancel","resetTimeout","onUploadProgress","event","loaded","UploadHttpClient","uploadFile","retryAsyncFunction","handleUploadError","urlStore","uploadURLFetchInProgress","fileUploadURL","progressTracker","objectKey","partUploadURL","filePart","etag","completeURL","encryptFileStream","fileStreamReader","initChunkEncryption","pushState","ref","pullCount","encryptedFileStream","encryptFileChunk","encryptedFileChunk","encryptFiledata","filedata","isDataStream","encryptFile","calculatePartCount","FILE_CHUNKS_COMBINED_FOR_A_UPLOAD_PART","uploadStreamUsingMultipart","dataStream","uploadPartCount","multipartUploadURLs","uploadStreamInParts","fileObjectKey","streamReader","getRandomProgressPerPartUpload","partEtags","partURLs","entries","combineChunksToFormUploadPart","uploadChunk","eTag","PartNumber","ETag","completeMultipartUpload","combinedChunks","i","options","compact","ignoreComment","spaces","CompleteMultipartUpload","Part","ENCRYPTION_CHUNK_SIZE","floor","object","UploadService","fileCount","metadataMap","pendingUploadCount","preFetchUploadURLs","rawFile","googleMetadata","Object","encryptionKey","encryptedFiledata","encryptThumbnail","encryptedThumbnail","encryptedMetadata","encryptToB64","encryptedKey","getUploadURL","thumbnailUploadURL","thumbnailObjectKey","backupedFile","keyDecryptionNonce","nonce","uploadURLs","fetchUploadURLs","FAILURE_REASON","RESPONSE_STATUS","convertBytesToGBs","bytes","precision","log","sizes","pow","hasPaidSubscription","getUserSubscription","isSubscriptionActive","isSubscribed","isSubscriptionCancelled","expiryTime","isOnFreePlan","isCancelled","getData","isUserSubscribedPlan","plan","stripeID","iosID","androidID","hasStripeSubscription","updateSubscription","setDialogMessage","setLoading","closePlanSelectorModal","cancelSubscription","activateSubscription","updatePaymentMethod","checkSubscriptionPurchase","router","query","sessionId","session_id","reason","fail","handleFailureReason","success","CANCELED","REQUIRE_PAYMENT_METHOD","AUTHENTICATION_FAILED","planForSubscription","storage","price","period","type","download","appendChild","click","remove","cachedFileUrl","fileNameWithoutExtension","toLowerCase","sortFilesIntoCollections","collectionWiseFiles","getSelectedFiles","selected","filesIDs","selectedFiles","val","getSelectedFileIds","foundFiles","formatDate","date","Intl","DateTimeFormat","weekday","year","month","day","format","formatDateTime","dateTimeFormat","timeFormat","timeStyle","formatDateRelative","units","hour","minute","second","relativeDateFormat","RelativeTimeFormat","localeMatcher","numeric","elapsed","u","abs","sort","b","decryptB64","decryptMetadata","removeUnnecessaryFileProps","msrc","h","html","w","lastDotPosition","lastIndexOf","substr","splitFilenameAndExtension","typeFromExtension","fileIsArchived","visibility","updateMagicMetadataProps","magicMetadataUpdates","magicMetadataProps","keys","updatePublicMagicMetadataProps","publicMetadataUpdates","publicMetadataProps","changeFilesVisibility","updatedFiles","updatedMagicMetadataProps","changeFileCreationTime","editedTime","updatedPublicMagicMetadataProps","changeFileName","editedName","isSharedFile","user","ownerID","updateExistingFilePubMetadata","existingFile","updatedFile","getFileFromURL","fileFile","getNonTrashedUniqueUserFiles","idSet","getUniqueFiles","isTrashed","downloadFiles","fileExtension","retrySleepTimeInMilliSeconds","func","checkForBreakingError","retrier","attemptNumber","sleep","isFirstLogin","setIsFirstLogin","justSignedUp","setJustSignedUp"],"sourceRoot":""}